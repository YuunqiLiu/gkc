/*
*
* Copyright (c) Tanel Tammet 2004-2019
*
* Contact: tanel.tammet@gmail.com                 
*
* This file is part of GK
*
*/

 /** @file jsparse.c
 *  json input data parser 
 *
 */

/* ====== Includes =============== */



#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
#include <ctype.h>


#include "../Db/dbdata.h"
#include "../Db/dbmem.h"
#include "../Db/dballoc.h"
#include "../Db/dbdata.h"
#include "../Db/dbmpool.h"
#include "../Printer/dbotterprint.h"
#include "../Reasoner/clterm.h"
#include "../Reasoner/history.h"
//#include "../Reasoner/histctxt.h"
#include "dbparse.h"
#include "dbgenparse.h"
#include "dbotterparse.h"
#include "dbclausify.h"

#include "jsparse.h"
//#include "../json/yajl_all.h"
#include "../json/yajl_api.h"

#include "../Reasoner/printerrutils.h"  
#include "dbgenparse.h"


/* ====== Private headers and defs ======== */

//#define DEBUG
//#undef DEBUG

//#define IDEBUG

#define DPRINTF(...) 

#define UNUSED(x) (void)(x);

void json_err_printf2(char* s1, char* s2);
void json_err_printfn2(char* s1, int num, char* s2);
void json_err_printf3(char* s1, int num, char* s2);

static int wr_show_jsparse_error(glb* g, parse_parm* pp, char* format, ...);


/* code structure:


  wg_import_js_file takes filename, calls
    wr_import_js_file takes filename, initialises pp structure, calls
      wr_yajl_parse_file storing result in pp.result,
      wr_preprocess_json_clauselist takes pp.result (json parser result)
        loops over all formulas and calls
        wr_process_json_formula for each formula giving a tptp fof structure as result
        reverses the end result
      wr_js_parse_clauselist takes resultlist of tptp fof structures given by the preprocessor above
        loops over fof formulas and calls
        wr_flatten_logclause for each
        loops over the result of the previous wf_flatten_logclause result list of clauses and calls
          wr_js_parse_clause for each clause, taking clause, name, vardata etc
            and building a gk record of the clause 
          adds a record built by the prev wr_js_parse_clause
*/


/* ======== functions ========================= */


int wg_import_js_file(void *db, char* filename, int iskb, int* informat,
        int askpolarity, int* askinfo, int streaming) {  
  glb* g;
  int res;

#ifdef DEBUG
  printf("wg_import_js_file starts for file %s\n",filename); 
#endif
  g=wr_glb_new_simple(db); // no complex values given to glb elements 
  if (g==NULL) return 1;   
  (g->parser_print_level)=0;
  (g->print_initial_parser_result)=0;
  (g->print_generic_parser_result)=1;
  res=wr_import_js_file(g,filename,NULL,NULL,iskb,askpolarity,askinfo,streaming);
  if (g->parse_errmsg) {
    printf("%s\n",(g->parse_errmsg));
    sys_free(g->parse_errmsg);
    //res=1;
  } else if (dbmemsegh(db)->errflag) {
    wg_show_db_error(db);
    res=1;
  }
  /*
  if (res==1) {  
    if (0) { //} ((g->print_flag) &&  (g->print_level_flag)) {
      db_printf("No clauses generated by parser.\n");  
    }
  } else {
    //wg_mpool_print(db,pres2);
    if (0) { //((g->print_flag) && (g->print_generic_parser_result)>0) {    
      printf("\nGeneric parser result:\n");
      //wr_print_db_otter(g,(g->print_clause_detaillevel));
    }  
  } 
  */
  *informat=3;
  (g->print_json)=1; 
  (g->print_clauses_json)=1;
  sys_free(g); // no complex values given to glb elements

  dprintf("wg_import_otterfile ends with res\n"); 
  return res;  
}


int wr_import_js_file(glb* g, char* filename, char* strasfile, cvec clvec, int isincluded,
      int askpolarity, int* askinfo, int streaming) {
  void* db=g->db;
  parse_parm  pp;
  //char* fnamestr;  
  //FILE* fp;    
  //char* buf; 
  //int pres=1;
  void* preprocessed=NULL;
  void* pres2=NULL;
  void *mpool;  
  int i,tmp_comp_funs;
  
#ifdef DEBUG
  //DPRINTF("wr_import_otter_file called\n");
  printf("\n filename %s \n",filename);
  printf("\n strasfile %s \n",strasfile);
  printf("\n isincluded %d \n",isincluded);
  (g->print_initial_parser_result)=1;
  (g->print_generic_parser_result)=1;
#endif        
  // set globals for parsing
  (g->filename)=filename;
  (g->parse_is_included_file)=isincluded;
  (g->parse_skolem_prefix)=wr_str_new(g,100);
  strncpy((g->parse_skolem_prefix),DEFAULT_SKOLEM_PREFIX,99);
  //(g->parse_skolem_nr)=0;
  (g->parse_newpred_prefix)=wr_str_new(g,100);
  strncpy((g->parse_newpred_prefix),DEFAULT_NEWPRED_PREFIX,99);
  //(g->parse_newpred_nr)=0;
  (g->parse_errmsg)=NULL;
  (g->parse_errflag)=0;

  tmp_comp_funs=(g->use_comp_funs);
  (g->use_comp_funs)=0;
  (g->in_has_fof)=0;

  //printf("\nwg_jsparse_data called\n");  
  mpool=wg_create_mpool(db,PARSER_MEMPOOL_SIZE);
  pp.askpolarity=askpolarity;
  pp.askinfo=0;
  pp.db=db;
  pp.filename=filename;
  pp.foo=NULL; // indicates file case in YY_INPUT in dbotter.l
  pp.result=NULL;
  pp.mpool=mpool;
  pp.depth=0;
  pp.formulanr=0;

  pp.jsonnull=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_NULL,NULL);
  pp.jsonstruct=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_STRUCT_PREFSTR,NULL);
  pp.jsontrue=wg_makelogtrue(db,mpool);
  pp.jsonfalse=wg_makelogfalse(db,mpool);
  pp.jsonempty=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_EMPTY,NULL);

  pp.logfof=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_FOF,NULL);
  pp.logtrue=pp.jsontrue; //wg_makelogtrue(db,mpool);
  pp.logfalse=pp.jsonfalse; //wg_makelogfalse(db,mpool);
  pp.logneg=wg_makelogneg(db,mpool);
  pp.logand=wg_makelogand(db,mpool);
  pp.logor=wg_makelogor(db,mpool);
  pp.logimp=wg_makelogimp(db,mpool);
  pp.logeqv=wg_makelogeqv(db,mpool);
  pp.logall=wg_makelogall(db,mpool);
  pp.logexists=wg_makelogexists(db,mpool); 
  pp.atomeq=wg_makeatomeq(db,mpool); 

  pp.logask=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_ASK,NULL); 

  pp.freevars=NULL;
  pp.freevarsnr=0;
  pp.nullvars=NULL;
  pp.nullvarsnr=0;
  pp.boundvars=NULL;

  for(i=0;i<PARSE_NESTING_DEPTH;i++) {
    pp.nests[i]=NULL;
  } 
  if (!pp.logtrue || !pp.logfalse || !pp.logneg || !pp.logand || !pp.logor
      || !pp.logimp || !pp.logeqv || !pp.logall || !pp.logexists || !pp.atomeq) {
    wr_show_jsparse_error(g,&pp,
      "cannot initialize pp ctxt in wr_process_tptp_import_clause\n");
    return 1;
  }
  if (strasfile==NULL) {  
    // input from file
    //fnamestr=filename;
    //if (fnamestr && fnamestr[0]=='#') fnamestr=fnamestr+1;
#ifdef DEBUG
    printf("\nreading from file %s\n",filename);
#endif       
    printf("\nreading from file %s\n",filename);
    wr_yajl_parse_file(g,&pp,filename, 
      clvec, isincluded,
      askpolarity, askinfo, mpool, streaming);   
  } else {
    // input from string      
    pp.filename="string";
    //strasfile="[-568,[7.459,-9.3e10, null, a]]";
#ifdef DEBUG
    printf("\nreading from string %s\n",strasfile);
#endif    
    pp.length = strlen(strasfile);
    pp.pos = 0;
    wr_yajl_parse_string(g,&pp,strasfile);       
  }   
#ifdef DEBUG
  printf("\njson parser result:\n");    
  wg_mpool_print(db,pp.result);
  printf("\n");
#endif

  printf("\njson parser result:\n");    
  wg_mpool_print(db,pp.result);
  printf("\n");

  if (pp.result!=NULL) {
    preprocessed=wr_preprocess_json_clauselist(g,&pp,clvec,pp.result,isincluded,0);
    //preprocessed=wr_clausify_clauselist(g,mpool,clvec,pp.result);
    pres2=wr_js_parse_clauselist(g,mpool,clvec,preprocessed);
  }
  *askinfo=pp.askinfo;
  wg_free_mpool(db,mpool);
  (g->use_comp_funs)=tmp_comp_funs; 
  //if (pres || pres2==NULL) return 1;
  if (pres2==NULL) return 1;
  else return 0;  
}

int wg_is_jsfile(void* db,char* filename) {
  char* suff;

  UNUSED(db);
  if (!filename) return 0;  
  suff=strrchr(filename,'.');
  if (suff==NULL) return 0;
  if (!strncmp(suff,".js",strlen(".js"))) return 1;
  return 0;
}

int wg_is_js_streaming_file(void* db,char* filename) {
  char* suff;

  UNUSED(db);
  if (!filename) return 0;  
  suff=strrchr(filename,'.');
  if (suff==NULL) return 0;
  if (!strncmp(suff,".jss",strlen(".jss"))) return 1;
  return 0;
}



// =============== parsing json ==========



/* memory debugging routines */
typedef struct
{
    unsigned int numFrees;
    unsigned int numMallocs;   
    parse_parm* pp;
} yajlTestMemoryContext;

/* cast void * into context */

#define TEST_CTX(vptr) ((yajlTestMemoryContext *) (vptr))

/*
static void yajlTestFree(void * ctx, void * ptr)
{
    assert(ptr != NULL);
    TEST_CTX(ctx)->numFrees++;
    free(ptr);
}

static void * yajlTestMalloc(void * ctx, size_t sz)
{
    assert(sz != 0);
    TEST_CTX(ctx)->numMallocs++;
    return malloc(sz);
}

static void * yajlTestRealloc(void * ctx, void * ptr, size_t sz)
{
    if (ptr == NULL) {
        assert(sz != 0);
        TEST_CTX(ctx)->numMallocs++;
    } else if (sz == 0) {
        TEST_CTX(ctx)->numFrees++;
    }

    return realloc(ptr, sz);
}
*/

//#define BUF_SIZE 2048

static int parse_yajl_null(void *ctx) {
  //int stringLen;
  //char* stringVal;
  parse_parm *pp = (parse_parm *) ctx;

  //printf("\nnull\n");   
  //stringVal=MPOOL_JSON_NULL;
  //stringLen=strlen(stringVal);
  if (!(pp->depth)) {
    //(pp->result)=MKWGURILEN(pp, (char*)stringVal, (int)stringLen);      
    (pp->result)=pp->jsonnull;
  } else {
    //(pp->nests)[(pp->depth)]=
    //  MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,pp->jsonnull,(pp->nests)[(pp->depth)]);
  }  
  return 1;
}

static int parse_yajl_boolean(void * ctx, int boolVal) {
  //int stringLen;
  //char* stringVal;
  parse_parm *pp = (parse_parm *) ctx;
  void* val;

  //printf("\nbool %d\n",boolVal); 
  /*
  if (boolVal) {
    stringVal=MPOOL_JSON_TRUE;
  } else {
    stringVal=MPOOL_JSON_FALSE;
  }
  stringLen=strlen(stringVal);
  */
  if (boolVal) {
    val=pp->jsontrue;
  } else {
     val=pp->jsonfalse;
  } 
  if (!(pp->depth)) {
    //(pp->result)=MKWGURILEN(pp, (char*)stringVal, (int)stringLen);      
    (pp->result)=val;
  } else {
    //(pp->nests)[(pp->depth)]=
    //  MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,val,(pp->nests)[(pp->depth)]);
  }  
  return 1;
}

static int parse_yajl_integer(void *ctx, long long integerVal) {
  parse_parm *pp = (parse_parm *) ctx; 

  //printf("integer: %lld\n", integerVal);
  if (!(pp->depth)) {
    (pp->result)=MKWGINTDIRECT(pp, (gint)integerVal);       
  } else {
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,MKWGINTDIRECT(pp, (gint)integerVal),(pp->nests)[(pp->depth)]);
  } 
  return 1;
}

static int parse_yajl_double(void *ctx, double doubleVal) {
  parse_parm *pp = (parse_parm *) ctx; 
   
  //printf("double1: %f\n", doubleVal);
  if (!(pp->depth)) {
    (pp->result)=MKWGDOUBLEDIRECT(pp, ((double)doubleVal)); 
    //(pp->result)=MKWGINTDIRECT(pp, (gint)doubleVal);      
  } else {
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,MKWGDOUBLEDIRECT(pp, ((double)doubleVal)),(pp->nests)[(pp->depth)]);      
  } 
  return 1;
}

static int parse_yajl_string(void *ctx, const unsigned char * stringVal,
                            size_t stringLen) {      
  parse_parm *pp = (parse_parm *) ctx;

  //printf("\nstringLen %ld stringVal |%s|\n",(gint)stringLen,stringVal); 
  //(pp->result)=MKWGSTRINGLEN(pp, stringVal, stringLen); 
  if (!(pp->depth)) {
    (pp->result)=MKWGURILEN(pp, (char*)stringVal, (int)stringLen);      
  } else {
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
  }  
  return 1;
}

static int parse_yajl_start_array(void *ctx) {  
  parse_parm *pp = (parse_parm *) ctx;   

  //printf("array open '['\n");
  (pp->depth)++; 
  (pp->nests)[(pp->depth)]=MKWGNIL;     
  //printf("\ndepth %d\n",(pp->depth));
  return 1;
}

static int parse_yajl_end_array(void *ctx) {  
  parse_parm *pp = (parse_parm *) ctx;

  //printf("array close ']'\n");  
  if (!((pp->depth)-1)) {
    if ((pp->nests)[(pp->depth)]==NULL) {
      ((pp->nests)[(pp->depth)])=pp->jsonempty;
    } else {
      (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
      (pp->result)=(pp->nests)[(pp->depth)];            
    }  
  } else {  
    if ((pp->nests)[(pp->depth)]==NULL) {
      ((pp->nests)[(pp->depth)-1])=//pp->jsonempty;
        MKWGPAIR(pp,pp->jsonempty,(pp->nests)[(pp->depth)-1]);  
    } else {
      (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
      (pp->nests)[(pp->depth)-1]=
        MKWGPAIR(pp,(pp->nests)[(pp->depth)],(pp->nests)[(pp->depth)-1]);      
    }    
  }
  (pp->depth)--; 
  //printf("\ndepth %d\n",(pp->depth));
  return 1;
}

static int parse_yajl_map_key(void *ctx, const unsigned char * stringVal,
                             size_t stringLen) {
  return parse_yajl_string(ctx,stringVal,stringLen);
}

static int parse_yajl_start_map(void *ctx) {
  //int stringLen;
  //char* stringVal;
  parse_parm *pp = (parse_parm *) ctx;     

  //printf("map open '{'\n");
  (pp->depth)++;
  (pp->nests)[(pp->depth)]=MKWGNIL;
  //stringVal=MPOOL_STRUCT_PREFSTR;
  //stringLen=strlen(stringVal);
  //(pp->nests)[(pp->depth)]=
  //  MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
  (pp->nests)[(pp->depth)]=
    MKWGPAIR(pp,pp->jsonstruct,(pp->nests)[(pp->depth)]);  
  //printf("\ndepth %d\n",(pp->depth));
  return 1;
}

static int parse_yajl_end_map(void *ctx) {  
  parse_parm *pp = (parse_parm *) ctx;

  //printf("\nmap close '}'\n");
  if (!((pp->depth)-1)) {
    (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
    (pp->result)=(pp->nests)[(pp->depth)];  
    //(pp->result)=wg_reverselist(pp->db,pp->mpool,(pp->result));          
  } else {  
    (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
    (pp->nests)[(pp->depth)-1]=
      MKWGPAIR(pp,(pp->nests)[(pp->depth)],(pp->nests)[(pp->depth)-1]); 
    //(pp->nests)[(pp->depth)-1]=wg_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)-1]);
  }
  (pp->depth)--; 
  //printf("\ndepth %d\n",(pp->depth));  
  return 1;
}

static yajl_callbacks callbacks = {
  parse_yajl_null,
  parse_yajl_boolean,
  parse_yajl_integer,
  parse_yajl_double,
  NULL,
  parse_yajl_string,
  parse_yajl_start_map,
  parse_yajl_map_key,
  //parse_yajl_string,
  parse_yajl_end_map,
  parse_yajl_start_array,
  parse_yajl_end_array
};



int wr_yajl_parse_file(glb* g, parse_parm* pp, char* filename,
      cvec clvec, int isincluded,
      int askpolarity, int* askinfo, void* mpool, int streaming) {
  yajl_handle hand;
  FILE *file;
  yajl_status stat;
  size_t rd;
  unsigned char *line, *str;  
  size_t len;        
  int bytes;
  int lines, i, endfound=0;
  yajlTestMemoryContext memCtx;  
  char errbuf[110];

  // try  
  void* db=g->db;
  //char* fnamestr;  
  //FILE* fp;    
  //char* buf; 
  //int pres=1;
  void* preprocessed=NULL;
  void* pres2=NULL;   
  int tmp_comp_funs;
  // try

  UNUSED(g);
  // memory allocation debugging: allocate a structure which collects
  // statistics    
  memCtx.numFrees=0;
  memCtx.numMallocs=0;
  memCtx.pp=pp;
  // allocate the parser 
  //hand = yajl_alloc(&callbacks, &allocFuncs, NULL);
  hand = yajl_alloc(&callbacks, NULL, (void*)pp);
  // configure parser
  yajl_config(hand, yajl_allow_comments, 1);
  yajl_config(hand, yajl_allow_multiple_values, 1); 
  // open file
  //fileData = (unsigned char *) malloc(bufSize);  
  if (filename) { 
    file = fopen(filename, "r");
    if (!file) {
      json_err_printf2("could not open",filename);      
      //printf("\ncould not open %s\n",filename);
      return -1;
    }
  } else {    
    json_err_printf2("no filename given",filename);
    //printf("\nno filename givenn");
    return -1;
  }
  //printf("\nstart to read\n");
  line=NULL;
  len=0;      
  lines=1;
  for (;;lines++) {     
    bytes = wg_getline(&line, &len, file);    

    printf("\nline %d read %d bytes\n",lines,bytes);
    printf("\n|%s|\n",line);

    rd=(size_t)bytes;
    if (bytes<=0) {

      printf("\nline %d bytes %d feof(file) %d\n",lines,bytes,feof(file));

      if (!feof(file)) {
        json_err_printf2("error reading from",filename);
        //printf("\nerror reading from %s\n", filename);
      } else {
        //endfound=1;
      }     
      break;
    } else {      

      printf("\nusing line |%s|\n",line);

      // read file data, now pass to parser
      stat = yajl_parse(hand, line, rd);

      // try
      if (streaming) {
        if (pp->result!=NULL) {
          preprocessed=wr_preprocess_json_clauselist(g,pp,clvec,pp->result,isincluded,1);
          //preprocessed=wr_clausify_clauselist(g,mpool,clvec,pp.result);
          pres2=wr_js_parse_clauselist(g,mpool,clvec,preprocessed);
        }
        *askinfo=pp->askinfo;
        //wg_free_mpool(db,mpool);
        (g->use_comp_funs)=tmp_comp_funs; 
        //if (pres || pres2==NULL) return 1;
        if (pres2==NULL) return 1;
        // try
      }


      if (stat != yajl_status_ok) break;
    }
  }    
  stat = yajl_complete_parse(hand);
  if ((stat != yajl_status_ok) && !endfound) {
    str =  yajl_get_error(hand, 0, line, rd);
    //fflush(stdout);
    //json_err_printf2("could not open file",fnamestr);
    if (str && strlen((char*)str)<100) {
      // remove trailing newline
      strcpy(errbuf,(char*)str);
      for(i=0; errbuf[i] && i<100;i++) {
        if (errbuf[i]=='\n') { errbuf[i]=(char)0; break; }        
      }
      json_err_printfn2("json syntax error at line ", lines,errbuf);         
    } else { 
      json_err_printfn2("json syntax error at line ", lines, (char *) str);            
    }  
    yajl_free_error(hand, (unsigned char *)str);
    return -1;
  }
  yajl_free(hand);
  if (line!=NULL) free(line);
  if (filename) {
    fclose(file);
  }
  // finally, print out some memory statistics
  if (memCtx.numMallocs - memCtx.numFrees) {
    printf("memory leaks:\t%u\n", memCtx.numMallocs - memCtx.numFrees);
  }  
  return 0;
}



int wr_yajl_parse_string(glb* g, parse_parm* pp, char* strasfile) {
  yajl_handle hand;
  yajl_status stat;
  size_t rd;
  unsigned char *line;
  yajlTestMemoryContext memCtx;

  UNUSED(g);
  // memory allocation debugging: allocate a structure which collects
  // statistics 
  memCtx.numFrees=0;
  memCtx.numMallocs=0;
  memCtx.pp=pp;
 
  // allocate the parser 
  //hand = yajl_alloc(&callbacks, &allocFuncs, NULL);
  hand = yajl_alloc(&callbacks, NULL, (void*)pp);
  // configure parser
  yajl_config(hand, yajl_allow_comments, 1);
  yajl_config(hand, yajl_allow_multiple_values, 1); 
  //printf("\nstart to parse str\n");
  line=(unsigned char *) strasfile;
  rd=strlen(strasfile);
  stat = yajl_parse(hand, line, rd); 
  stat = yajl_complete_parse(hand);
  if (stat != yajl_status_ok) {
    unsigned char * str = yajl_get_error(hand, 0, line, rd);
    //fflush(stdout);
    json_err_printf2("json syntax error:",(char *) str);
    yajl_free_error(hand, str);
    return -1;
  }
  yajl_free(hand);
  // finally, print out some memory statistics
  if (memCtx.numMallocs - memCtx.numFrees) {
    //printf("memory leaks:\t%u\n", memCtx.numMallocs - memCtx.numFrees);
  }  
  return 0;
}

/*

getline replacement 

*/

int wg_getline(unsigned char **restrict line, size_t *restrict len, FILE *restrict fp) {
  char chunk[128];

  // Check if either line, len or fp are NULL pointers
  if(line == NULL || len == NULL || fp == NULL) {        
    return -1;
  }        
  // Allocate a block of memory for *line if it is NULL or smaller than the chunk array
  if(*line == NULL || *len < sizeof(chunk)) {
    *len = sizeof(chunk);
    if((*line = malloc(*len)) == NULL) {     
      return -1;
    }
  }
  (*line)[0] = '\0';
  while(fgets(chunk, sizeof(chunk), fp) != NULL) {
    // Resize the line buffer if necessary
    size_t len_used = strlen((char*)(*line));
    size_t chunk_used = strlen(chunk);

    if(*len - len_used < chunk_used) {
      // Check for overflow
      if(*len > SIZE_MAX / 2) {
        return -1;
      } else {
        *len *= 2;
      }      
      if((*line = realloc(*line, *len)) == NULL) {
        return -1;
      }
    }
    // Copy the chunk to the end of the line buffer
    memcpy(*line + len_used, chunk, chunk_used);
    len_used += chunk_used;
    (*line)[len_used] = '\0';

    // Check if *line contains '\n', if yes, return the *line length
    if((*line)[len_used - 1] == '\n') {
      return len_used;
    } else {
      return len_used;
    }
  }
  return -1;
}

/* ----------- preprocess json clauselist ----------- */



void* wr_preprocess_json_clauselist
        (glb* g,parse_parm* pp,cvec clvec,void* clauselist, int isincluded, 
        int streaming) {
  void* mpool=pp->mpool;          
  void* db=g->db;
  void* lpart;
  void *cl; //, *clname, *clrole;
  void* resultclause=NULL;
  void* resultlist=NULL;
  int clnr=0;
  //char namebuf[1000];
  //char rolebuf[100];
#ifdef DEBUG  
  printf("wr_preprocess_json_clauselist starting with clauselist\n");  
  wg_mpool_print(db,clauselist);
  printf("\n");
#endif       

  // loop over clauses

  if (streaming) {
    cl=clauselist;
    if (wr_is_json_import_clause(db,cl)) {
      // tptp import clause 
      wr_process_json_import_clause(g,mpool,cl);
      resultclause=NULL;
    } else {      
      resultclause=wr_process_json_formula(g,pp,cl);      
    } 
#ifdef DEBUG
    printf("\nin wr_preprocess_json_clauselist resultclause:\n");
    wg_mpool_print(db,resultclause); 
    printf("\n\n"); 
#endif
    printf("\nin wr_preprocess_json_clauselist resultclause:\n");
    wg_mpool_print(db,resultclause); 
    printf("\n\n");
    if (resultclause!=NULL) {
      resultlist=wg_mkpair(db,mpool,resultclause,resultlist);  
    }  
  } else {

    for(lpart=clauselist,clnr=0;wg_ispair(db,lpart);lpart=wg_rest(db,lpart),clnr++) {
      if (g->parse_errflag) break;
      cl=wg_first(db,lpart);
  #ifdef DEBUG    
      printf("\nclause nr %d:",clnr);    
      wg_mpool_print(db,cl); 
      printf("\n");   
  #endif    

      printf("\nclause nr %d:",clnr);    
      wg_mpool_print(db,cl); 
      printf("\n");

      if (!clnr && wg_isatom(db,cl) && wg_atomtype(db,cl)==WG_URITYPE &&
            !strcmp("formulas",wg_atomstr1(db,cl)) ) {
        clnr--;      
        continue;
      }
      pp->formulanr=clnr+1;
      if (wg_isatom(db,cl) && wg_atomtype(db,cl)!=WG_URITYPE) {
        if (cl==(pp->logtrue)) continue;
        if (cl!=(pp->logfalse)) {
          wr_show_jsparse_error(g,pp,"not a proper formula at top level");
          break;
        } else {
          // make a falsehood        
        }
      }   
      if (wr_is_json_import_clause(db,cl)) {
        // tptp import clause 
        wr_process_json_import_clause(g,mpool,cl);
        resultclause=NULL;
      } else {      
        resultclause=wr_process_json_formula(g,pp,cl);      
      } 
  #ifdef DEBUG
      printf("\nin wr_preprocess_json_clauselist resultclause:\n");
      wg_mpool_print(db,resultclause); 
      printf("\n\n"); 
  #endif
      if (resultclause!=NULL) {
        resultlist=wg_mkpair(db,mpool,resultclause,resultlist);  
      }  
    } // end clause list loop 
    //free(vardata); // if taken from mpool, not freed

    if (g->parse_errflag) {
      //printf("\n%s\n",g->parse_errmsg);
      return NULL;
    }
  }

#ifdef DEBUG
  printf("\nin wr_preprocess_json_clauselist resultlist:\n");
  wg_mpool_print(db,resultlist); 
  printf("\n\n");  
#endif
  
  resultlist=wg_inplace_reverselist(db,mpool,resultlist);
  return resultlist;
}  

// like: ((u:include u:Axioms/SWC001-0.ax))

int wr_is_json_import_clause(void* db, void* cl) {
  void* fun;

  if (wg_isatom(db,cl)) return 0;
  fun=wg_first(db,cl);
  if (!wg_islog_uri(db,fun,"include")) return 0;
  if (wg_list_len(db,cl)!=2) return 0;
  return 1;
}


void* wr_process_json_import_clause(glb* g, void* mpool, void* cl) {
  void* db=g->db;
  void* pathatom;
  char* str;
  char* filename=NULL;
  FILE* fp;
  int bytes;
  char* axiomfolder="/opt/TPTP/";
  char* envfolder=NULL;
  char *lastslash = NULL;
  //char *parent = NULL;
  char* p1;
  char* p2;
  char* str2;
  //int tmp;
 
#ifdef IDEBUG
  printf("\nwr_process_tptp_import_clause starts with\n");
  wg_mpool_print(db,cl); 
  printf("\n");
  printf("\nproblem filename is %s\n",g->filename);
#endif

  if (!(g->filename) || strlen(g->filename)<1) {
    wr_show_jsparse_error(g,NULL,"no filename given in wr_process_tptp_import_clause\n");
    return NULL;
  }
  pathatom=wg_nth(db,cl,1);
  envfolder=getenv("TPTP");
#ifdef IDEBUG
  //printf("\npathatom is\n");
  //wg_mpool_print(db,pathatom); 
  printf("\nTPTP env var value is %s\n",envfolder);
  printf("\n$TPTP env var value is  %s\n",getenv("$TPTP"));
  //wg_mpool_print(db,envfolder);
  //printf("\nwg_atomtype(db,pathatom) %d WG_URITYPE %d\n",wg_atomtype(db,pathatom),WG_URITYPE);
  //printf("\n");
#endif  
  if (wg_atomtype(db,pathatom)!=WG_URITYPE) return 0;  
  str=wg_atomstr1(db,pathatom); 
  if (str && str[0]=='#') str=str+1;
  lastslash=strrchr(g->filename,'/');
  if (lastslash!=NULL) {
    bytes=strlen(str)+strlen(g->filename)+10;
    str2=wg_alloc_mpool(db,mpool,bytes);
    if (!str2) return NULL;
    for(p1=(g->filename), p2=str2; p1<lastslash; p1++, p2++) {
      *p2=*p1;
    }
    *p2=(char)0;    
    strcat(str2,"/");
    strcat(str2,str);    
  } else {
    str2=str;
  }  
#ifdef IDEBUG
  //printf("\nstr %s\n",str);
  //printf("\nstr2 %s\n",str2);
  fp=fopen(str,"r");
  if (fp!=NULL) {
    printf("\nfile %s found\n",str); 
    fclose(fp);
  } else {
    printf("\nfile %s not found\n",str); 
  }  
  fp=fopen(str2,"r");
  if (fp!=NULL) {
    printf("\nfile %s found\n",str2); 
    fclose(fp);
  } else {
    printf("\nfile %s not found\n",str2); 
  }  
#endif
  //printf("\nfirst import path str2: %s\n",str2);  
  fp=fopen(str2,"r");
  if (fp!=NULL) {
    // succeeded to open axiom file: use that
    fclose(fp);
    filename=str2; 
  } else {
    if (envfolder) axiomfolder=envfolder;
    // failed to open axiom file: try env or default axiom folder
    bytes=strlen(str)+strlen(axiomfolder)+10;
    filename=wg_alloc_mpool(db,mpool,bytes);
#ifdef IDEBUG
    printf("\nalloced filename %s\n",filename);
#endif    
    if (!filename) {
      wr_show_jsparse_error(g,NULL,"cannot allocate filename in wr_process_tptp_import_clause\n");
      return NULL;
    }
    strcpy(filename,axiomfolder);
    if (envfolder) strcat(filename,"/");
    strcat(filename,str);
    //printf("\nsecond import path str: %s\n",filename);
  }
  //tmp=
#ifdef IDEBUG
  printf("\nfilename %s\n",filename);
#endif   
  wr_import_otter_file(g,filename,NULL,NULL,1);  
  return NULL;
}


/* ------------ process normal json formula ------------------- */


void* wr_process_json_formula(glb* g,parse_parm* pp, void* cl) {
  void* mpool=pp->mpool;
  void* db=g->db;
  //void* logconn;
  void *preres=NULL; 
  void *origcl, *res, *name, *role, *content, *tmp;
  char* rolestr;
  char namebuf[16];
  char rolebuf[16];

#ifdef DEBUG
  printf("\nwr_process_json_formula called\n");
  wg_mpool_print(db,cl);
  printf("\n"); 
#endif
  pp->formulaname=NULL;
  pp->formularole=NULL;
  pp->freevars=NULL;
  pp->freevarsnr=0;
  pp->nullvars=NULL;
  pp->nullvarsnr=0;
  pp->boundvars=NULL;

  name=NULL;
  role=NULL;
  origcl=cl;
  if (cl==NULL) {
    preres=NULL;  
  } else {
    // process keyval
    if (wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct)) {
      name=wg_get_keystrval(db, "name", cl);
      role=wg_get_keystrval(db, "role", cl);
      content=wg_get_keystrval(db, "content", cl);      
      if((name && !wg_isatom(db,name)) || (role && !wg_isatom(db,role))) {
        wr_show_jsparse_error(g,pp,"formula name and role must be strings");
        return NULL;     
      } else {
        if (name) pp->formulaname=wg_atomstr1(db,name);
        if (role) {
          rolestr=wg_atomstr1(db,role);          
          pp->formularole=rolestr;                         
        }  
        if (role && strcmp(rolestr,"axiom") && strcmp(rolestr,"assumption") &&
            strcmp(rolestr,"conjecture") && strcmp(rolestr,"negated_conjecture")  &&
            strcmp(rolestr,"question") &&
            strcmp(rolestr,"ask")) {
          wr_show_jsparse_error(g,pp,"unknown role value used");  
        } else if (content) {
          cl=content;
        } else {
          wr_show_jsparse_error(g,pp,"json object has no content key value");        
        }
      }
    }
    // process logic
    if (!(g->parse_errflag)) {
      preres=wr_process_json_formula_aux(g,pp,cl); 
      //printf("\nrole %ld and rolestr %s\n",(gint)role,rolestr); 
      if (preres) {
        if (role && !strcmp(rolestr,"question")) {

          //add negation like normally done, but keep freevars free

          pp->formularole="negated_conjecture";
          role=wg_mkatom(db,mpool,WG_URITYPE,pp->formularole,NULL);
          if (pp->freevars) {
            tmp=wg_mkatom(db,mpool,WG_URITYPE,"$ans",NULL);
            tmp=wg_mkpair(db,mpool,tmp,pp->freevars);
            tmp=wg_mklist3(db,mpool,pp->logimp,preres,tmp);
            preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,tmp);
          } else {             
            preres=wg_mklist2(db,mpool,pp->logneg,preres);
          }
        } else if (role && !strcmp(rolestr,"ask")) {          
          pp->askinfo=1; //ask role was found 
          if (pp->askpolarity) {
            printf("\n * try to answer positively: add negation  \n");
            // try to answer positively: add negation like normally done, but keep freevars free
            pp->formularole="negated_conjecture";
            role=wg_mkatom(db,mpool,WG_URITYPE,pp->formularole,NULL);
            
            if (pp->freevars) {
              tmp=wg_mkatom(db,mpool,WG_URITYPE,"$ans",NULL);
              tmp=wg_mkpair(db,mpool,tmp,pp->freevars);
              tmp=wg_mklist3(db,mpool,pp->logimp,preres,tmp);
              preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,tmp);
            } else {             
              preres=wg_mklist2(db,mpool,pp->logneg,preres);
            } 
          } else {               
            // try to answer negatively: do not add negation, yet keep freevars free
            printf("\n * try to answer negatively: do not add negation  \n");           
            pp->formularole="conjecture";
            role=wg_mkatom(db,mpool,WG_URITYPE,pp->formularole,NULL);
            if (pp->freevars) {              
              tmp=preres;
              preres=wg_mklist3(db,mpool,pp->logexists,pp->freevars,tmp);
              preres=wg_mklist2(db,mpool,pp->logneg,preres);
            } else {             
              preres=wg_mklist2(db,mpool,pp->logneg,preres);
            }                                            
          } 
        } else if (pp->freevars) {
          preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,preres);
        }
      }      
    }  
  }
  
  if (g->parse_errflag) {
    //printf("\n%s\n",g->parse_errmsg);
    return NULL;
  }

  if (!name) {
    sprintf(namebuf,"cl_%d",pp->formulanr);
    name=wg_mkatom(db,mpool,WG_URITYPE,namebuf,NULL);
  }   
  if (!role) {
    sprintf(rolebuf,"axiom");
    role=wg_mkatom(db,mpool,WG_URITYPE,rolebuf,NULL);
  }  
  if (!name  || !role) {
    wr_show_jsparse_error(g,pp,"cannot make a clause name or role");
    return NULL;
  }
  preres=wg_mklist4(db,mpool,NULL,name,role,preres);
 
#ifdef DEBUG
  printf("\nwr_process_json_formula preres is\n");
  wg_mpool_print(db,preres);
  printf("\n");  

  printf("\nwr_process_json_formula freevars is\n");
  wg_mpool_print(db,pp->freevars);
  printf("\n");  

  printf("\nwr_process_json_formula boundvars is\n");
  wg_mpool_print(db,pp->boundvars);
  printf("\n");  

  printf("\nwr_process_json_formula nullvars is\n");
  wg_mpool_print(db,pp->nullvars);
  printf("\n");  
   
  printf("\nbefore wr_preprocess_tptp_fof_clause\n");
  wg_mpool_print(db,preres);
  printf("\n");
#endif  

  preres=wr_preprocess_tptp_fof_clause(g,mpool,preres,NULL);

#ifdef DEBUG  
  printf("\nafter wr_preprocess_tptp_fof_clause\n");
  wg_mpool_print(db,preres);
  printf("\n");
#endif

  //res=wg_mklist3(db,mpool,name,role,preres);
  res=wg_mklist4(db,mpool,name,role,preres,origcl);

#ifdef DEBUG
  printf("\nwr_process_json_formula result is\n");
  wg_mpool_print(db,res);
  printf("\n");
#endif  
  return res;
}


void* wr_process_json_formula_aux(glb* g, parse_parm* pp, void* cl) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void* preres=NULL;
  void *res, *head, *logconn, *newlogconn;
  void *r1, *r2, *r1el; 
  void *r1proc, *r2proc;
  void *content; // *name, 
  int isneg,isreverse;

#ifdef DEBUG
  printf("\nwr_process_json_formula_aux called\n");
  wg_mpool_print(db,cl);
  printf("\n");
#endif
  if (cl==NULL) {
    return NULL;
  } 
  // process keyval
  if (wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct)) {
    //name=wg_get_keystrval(db, "name", cl);
    content=wg_get_keystrval(db, "content", cl);
    if (content) {
      return wr_process_json_formula_aux(g,pp,content);
    } else {
      wr_show_jsparse_error(g,pp,"json object has no content key value");
      return NULL;
    }
  }
  // now cl is not a keyval
  if (cl==NULL) {
    preres=NULL;
  } else if (wg_isatom(db,cl)) {
    if (cl==pp->jsonnull) {
      wr_show_jsparse_error(g,pp,"null can be used only inside an atom, not at the formula level");
      return NULL;
    }
    preres=wr_process_json_term(g,pp,cl,1,0);     
  } else {
    // get main parts
    head=wg_first(db,cl);       
    r1=wg_rest(db,cl);
    if (r1!=NULL) {
      r1el=wg_first(db,r1);
      r2=wg_rest(db,r1);    
    } else {
      r1el=NULL;
      r2=NULL;
    }  
    // process logical structure
    logconn=wr_json_list_logconn(g,pp,cl);
    if (head==NULL) {
      wr_show_jsparse_error(g,pp,"null value at the head of a logical list");
      return NULL;
    } else if (wg_isatom(db,head) &&
               (!strcmp("not",wg_atomstr1(db,head)) ||
                !strcmp("-",wg_atomstr1(db,head)) ||
                !strcmp("~",wg_atomstr1(db,head)) )) {     
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for not connective");
        return NULL;
      }          
      if (r2!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for not connective");
        return NULL;
      }      
      r1proc=wr_process_json_formula_aux(g,pp,r1el);
      if (r1proc==NULL) return NULL;
      *((gint*)cl)=(gint)(pp->logneg);
      *((gint*)r1)=(gint)r1proc;
      preres=cl;      
    } else if (wg_isatom(db,head) && !strcmp("exists",wg_atomstr1(db,head))) {      
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for exists connective");
        return NULL;
      }
      if (!wr_json_is_atomlist(db,r1el)) {
        wr_show_jsparse_error(g,pp,"first argument of exists connective not a variable list");
        return NULL;
      }    
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for exists connective");
        return NULL;
      }
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for exists connective");
        return NULL;
      }
      (pp->boundvars)=wg_mkpair(db,mpool,r1el,(pp->boundvars));
      r2proc=wr_process_json_formula_aux(g,pp,wg_first(db,r2));
      (pp->boundvars)=wg_rest(db,(pp->boundvars));
      if (r2proc==NULL) return NULL;
      *((gint*)cl)=(gint)(pp->logexists);
      *((gint*)r2)=(gint)r2proc;
      preres=cl;
    } else if (wg_isatom(db,head) && !strcmp("forall",wg_atomstr1(db,head))) {      
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for forall connective");
        return NULL;
      }
      if (!wr_json_is_atomlist(db,r1el)) {
        wr_show_jsparse_error(g,pp,"first argument of forall connective not a variable list");
        return NULL;
      }      
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for forall connective");
        return NULL;
      }
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for forall connective");
        return NULL;
      }
      (pp->boundvars)=wg_mkpair(db,mpool,r1el,(pp->boundvars));    
      r2proc=wr_process_json_formula_aux(g,pp,wg_first(db,r2));
      (pp->boundvars)=wg_rest(db,(pp->boundvars));
      if (r2proc==NULL) return NULL;
      *((gint*)cl)=(gint)(pp->logall);
      *((gint*)r2)=(gint)r2proc;
      preres=cl;
    } else if (wg_isatom(db,head) && !strcmp("if",wg_atomstr1(db,head))) {
      preres=wr_json_process_if_then(g,pp,cl);   
    } else if (logconn!=NULL) {
      // contains logical stuff at top
      preres=wg_inplace_reverselist(db,mpool,cl);
#ifdef DEBUG      
      printf("\nwr_process_json_formula_aux reverse result is\n");
      wg_mpool_print(db,preres);
      printf("\n");
#endif      
      newlogconn=wr_json_translate_connective(g,pp,logconn);
      isneg=wr_json_negtype_connective(g,pp,logconn);
      if (wg_isatom(db,logconn) && !strcmp("<=",wg_atomstr1(db,logconn))) isreverse=1;
      else isreverse=0;
      preres=wr_json_unflatten_logic(g,pp,preres,logconn,newlogconn,!isneg,isreverse);      
    } else {
      preres=wr_process_json_term(g,pp,cl,1,0);
    }
  }
  res=preres;
#ifdef DEBUG  
  printf("\nwr_process_json_formula_aux result is\n");
  wg_mpool_print(db,res);
  printf("\n");
#endif
  return res;
}


void* wr_process_json_term(glb* g, parse_parm* pp, void* cl, int atomlevel, int pos) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void* preres=NULL;

  void *content, *head;
  void *a1, *a2;  
  void *r1, *r2,  *r1el; 
  void *tmp, *part; 
  int n, found;

#ifdef DEBUG
  printf("\nwr_process_json_term called\n");
  wg_mpool_print(db,cl);
  printf("\n");
#endif
  if (atomlevel) {
    pp->nullvars=NULL;
    pp->nullvarsnr=0;
  }
  // process keyval
  if (wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct)) {
    //name=wg_get_keystrval(db, "name", cl);
    content=wg_get_keystrval(db, "content", cl);
    if (content) {
      return wr_process_json_term(g,pp,content,atomlevel,pos);
    } else {
      wr_show_jsparse_error(g,pp,"json object has no content key value");
      return NULL;
    }
  }
  // now cl is not a keyval
  if (cl==NULL) {
    preres=NULL;
  } else if (wg_isatom(db,cl)) {  
    if (cl==pp->jsonnull) {
      if (atomlevel) {
        wr_show_jsparse_error(g,pp,"null can be used only inside an atom, not at the formula level");
        return NULL;
      }
      if (!pos) {
        wr_show_jsparse_error(g,pp,"first element of a list must be a symbol, not null");
        return NULL;
      }     
      a1=wr_json_make_nullvar(g,pp);
      if (!a1) return NULL;
      pp->nullvars=wg_mkpair(db,mpool,a1,pp->nullvars);
      return a1;
    } else if (wg_atomtype(db,cl)!=WG_URITYPE && cl!=pp->logfalse && cl!=pp->logtrue) {
      // not an uri
      if (!pos) {
        wr_show_jsparse_error(g,pp,"first element of a list must be a symbol, not a number");
        return NULL;
      }      
      preres=cl;
    } else if (!atomlevel && pos && wr_is_json_freevar(g,pp,cl)) {
      // variable case
      if (!wg_list_memberuri(db,(pp->freevars),cl)) {
        found=0;
        for(part=(pp->boundvars); part!=NULL; part=wg_rest(db,part)) {          
          if (wg_list_memberuri(db,wg_first(db,part),cl)) {
            found=1;
            break;
          }
        }
        if (!found) (pp->freevars)=wg_mkpair(db,mpool,cl,(pp->freevars));
      }
      preres=cl;
    } else {
      preres=cl;
    }     
  } else {
    // a list
    head=wg_first(db,cl);    
    r1=wg_rest(db,cl);
    if (r1!=NULL) {
      r1el=wg_first(db,r1);
      r2=wg_rest(db,r1);    
    } else {
      r1el=NULL;
      r2=NULL;
    }

    if (atomlevel && wg_isatom(db,r1el) && 
        (!strcmp("=",wg_atomstr1(db,r1el)) | 
         !strcmp("!=",wg_atomstr1(db,r1el)) )) { 
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"too few arguments for = or !=");
        return NULL;
      }         
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for = or !=");
        return NULL;
      }     
      a1=wr_process_json_term(g,pp,head,0,1);
      a2=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
      if (!a1 || !a2) return NULL;
      if (!strcmp("=",wg_atomstr1(db,r1el)))  {
        //preres=wg_mklist3(db,mpool,pp->eq,a1,a2);
        CP1
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;        
        preres=cl;
      } else {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;
        preres=wg_mklist2(db,mpool,pp->logneg,cl);         
      }  
      if (preres==NULL) {
        wr_show_jsparse_error(g,pp,"failed to process = : memory overflow");
        return NULL;
      }
      //return preres;
    } else if (atomlevel &&  wg_isatom(db,head) && 
        (!strcmp("=",wg_atomstr1(db,head)) | 
         !strcmp("!=",wg_atomstr1(db,head)) |
         !strcmp("-=",wg_atomstr1(db,head)) |
         !strcmp("~=",wg_atomstr1(db,head)) )) {
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"too few arguments for = or !=");
        return NULL;
      }         
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for = or !=");
        return NULL;
      }     
      a1=wr_process_json_term(g,pp,r1el,0,1);
      a2=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
      if (!a1 || !a2) return NULL;
      if (!strcmp("=",wg_atomstr1(db,head)))  {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;
        preres=cl;
      } else {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;
        preres=wg_mklist2(db,mpool,pp->logneg,cl);
        if (preres==NULL) {
          wr_show_jsparse_error(g,pp,"failed to process = : memory overflow");
          return NULL;
        }
      }
      //return preres; 
    } else if (!wg_isatom(db,head)) {
      wr_show_jsparse_error(g,pp,"atom must not start with a list");
      return NULL;
    } else if (wg_atomtype(db,head)!=WG_URITYPE) {
      wr_show_jsparse_error(g,pp,"atom must start with a constant");
      return NULL;
    } else if ((wg_atomstr1(db,head))[0]=='\0') {
      wr_show_jsparse_error(g,pp,"atom must not start with an empty string");
      return NULL;
    } else if (atomlevel && 
                ( (wg_atomstr1(db,head))[0]=='-' ||
                  (wg_atomstr1(db,head))[0]=='~' )) {  

      for(n=0,part=cl; part!=NULL; part=wg_rest(db,part),n++) {
        tmp=wr_process_json_term(g,pp,wg_first(db,part),0,n);
        if (tmp==NULL) return NULL;
      }              
      tmp=wg_mkatom(db,mpool,WG_URITYPE,(wg_atomstr1(db,head)+1),NULL);      
      *((gint*)cl)=(gint)tmp;
      preres=wg_mklist2(db,mpool,pp->logneg,cl);
      if (!tmp || !preres) {
        wr_show_jsparse_error(g,pp,"cannot process neg atom: memory overflow");
        return NULL;
      }
    } else {
      for(n=0,part=cl; part!=NULL; part=wg_rest(db,part),n++) {
        tmp=wr_process_json_term(g,pp,wg_first(db,part),0,n);
        if (tmp==NULL) return NULL;
        *((gint*)part)=(gint)tmp;
      }
      preres=cl;
    }
  }
  if (atomlevel && pp->nullvars) {
    preres=wg_mklist3(db,mpool,pp->logexists,pp->nullvars,preres);
  }
  return preres;
}

void* wr_json_list_logconn(glb* g, parse_parm* pp, void* cl) {
  void* db=g->db;
  void* part;
  void* el;
  void* foundconn=NULL;
  int nr;

  if (cl==NULL) return NULL;
  if (wg_isatom(db,cl)) return NULL;
  for(part=cl,nr=0; wg_ispair(db,part); part=wg_rest(db,part),nr++) {   
    el=wg_first(db,part);
    if (wr_json_is_connective(g,el)) {
      if (foundconn==NULL) {
        foundconn=el;
      } else if (!wr_json_equal_atoms(g,foundconn,el)) {
        //(g->parse_errflag)=1;
        wr_show_jsparse_error(g,pp,"different logical connectives in list: %s %s",foundconn,el);
        //printf("\nerr %s\n",(g->parse_errmsg));
        //json_err_printf2("different logical connectives in list containing", char* s2)
        return NULL;
      }
    }
  }
  return foundconn;      
}

int wr_json_is_atomlist(void* db,void* ptr) {
  void *el;

#ifdef DEBUG
  printf("\nwr_json_is_atomlist called with\n");
  wg_mpool_print(db,ptr);
  printf("\n");
#endif
  if (ptr==NULL) return 0;
  if (wg_isatom(db,ptr)) return 0;
  while(ptr != NULL) {    
    el=wg_first(db,ptr);
    if (!wg_isatom(db,el) || wg_atomtype(db,el)!=WG_URITYPE) return 0;
    ptr=wg_rest(db,ptr);   
  }
  return 1;
}

int wr_json_is_connective(glb* g,void* ptr) {
  void* db=g->db;
  char* str;

  if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_URITYPE) return 0; 
  str=wg_atomstr1(db,ptr);
  if (!strcmp("not",str)) return 1;
  if (!strcmp("~",str)) return 1;
  if (!strcmp("-",str)) return 1;

  if (!strcmp("and",str)) return 1;
  if (!strcmp("or",str)) return 1;   
  if (!strcmp("&",str)) return 1;
  if (!strcmp("|",str)) return 1;

  if (!strcmp("if",str)) return 1;
  
  if (!strcmp("forall",str)) return 1;
  if (!strcmp("exists",str)) return 1;

  if (!strcmp("<=>",str)) return 1;
  if (!strcmp("=>",str)) return 1;
  if (!strcmp("<=",str)) return 1;
  if (!strcmp("<~>",str)) return 1;
  if (!strcmp("~|",str)) return 1;
  if (!strcmp("~&",str)) return 1;
  
  //if (!strcmp("=",str)) return 1;
  //if (!strcmp("!=",str)) return 1;

  return 0;  
}

void* wr_json_translate_connective(glb* g,parse_parm* pp,void* ptr) {
  void* db=g->db;
  char* str;

  //if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_STRTYPE) return 0; 
  str=wg_atomstr1(db,ptr);
  if (!strcmp("not",str)) return pp->logneg;
  if (!strcmp("~",str)) return  pp->logneg;
  if (!strcmp("-",str)) return  pp->logneg;

  if (!strcmp("and",str)) return pp->logand;
  if (!strcmp("or",str)) return pp->logor;   
  if (!strcmp("&",str)) return pp->logand;
  if (!strcmp("|",str)) return pp->logor;

  if (!strcmp("forall",str)) return pp->logexists;
  if (!strcmp("exists",str)) return pp->logall; 

  if (!strcmp("<=>",str)) return pp->logeqv;
  if (!strcmp("=>",str)) return pp->logimp;
  if (!strcmp("<=",str)) return pp->logimp;
  if (!strcmp("<~>",str)) return pp->logeqv;
  if (!strcmp("~|",str)) return pp->logor;
  if (!strcmp("~&",str)) return pp->logand;

  if (!strcmp("ask",str)) return pp->logask;   
  //if (!strcmp("=",str)) return NULL;
  //if (!strcmp("!=",str)) return NULL;

  return NULL;  
}

int wr_json_negtype_connective(glb* g,parse_parm* pp,void* ptr) {
  void* db=g->db;
  char* str;

  //if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_STRTYPE) return 0; 
  str=wg_atomstr1(db,ptr);
  
  if (!strcmp("<~>",str)) return 1;
  if (!strcmp("~|",str)) return 1;
  if (!strcmp("~&",str)) return 1;
 
  return 0;  
}

int wr_is_json_freevar(glb* g,parse_parm* pp,void* ptr) {
  void* db=g->db;
  char *s;
  if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_URITYPE) return 0;
  s=wg_atomstr1(db,ptr);
  if ((*s)=='\0') return 0;
  if (*s >= 'A' && *s <= 'Z') return 1;      
  return 0;
}  

int wr_json_equal_atoms(glb* g,void* a1, void* a2) {
  void* db=g->db;
  char* str1;
  char* str2;

  if (!wg_isatom(db,a1) || wg_atomtype(db,a1)!=WG_URITYPE) return 0;
  if (!wg_isatom(db,a2) || wg_atomtype(db,a2)!=WG_URITYPE) return 0;
  str1=wg_atomstr1(db,a1);
  str2=wg_atomstr1(db,a2);
  if (!strcmp(str1,str2)) return 1;
  return 0;
}

void* wr_json_process_if_then(glb* g, parse_parm* pp, void* ptr) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void *res; //,*a2,*a1r,*rst;
  void *el, *cond=NULL, *conseq=NULL;
  void* part;
  int incond=1, condcount=0, conseqcount=0;

  //printf("\nwr_json_process_if_then called\n");
  for(part=wg_rest(db,ptr); part!=NULL;  part=wg_rest(db,part)) {
    el=wg_first(db,part);
    if (wg_isatom(db,el) && wg_atomtype(db,el)==WG_URITYPE &&
        !strcmp(wg_atomstr1(db,el),"then")) {
      incond=0;
      continue;
    }
    el=wr_process_json_formula_aux(g,pp,el);
    if (el==NULL) return NULL;
    if (incond) {
      condcount++;
      cond=wg_mkpair(db,mpool,el,cond);
    } else {
      conseqcount++;
      conseq=wg_mkpair(db,mpool,el,conseq);
    }   
  }
  if (incond) {
    wr_show_jsparse_error(g,pp,"if ... construction has no then part");
    return NULL;
  }
  if (!condcount) {
    wr_show_jsparse_error(g,pp,"if ... then ... construction has no conditions");
    return NULL;
  }
  if (!conseqcount) {
    wr_show_jsparse_error(g,pp,"if ... then ... construction has no consequences");
    return NULL;
  }
  if (condcount>1) {
    cond=wg_inplace_reverselist(db,mpool,cond);
    cond=wg_mkpair(db,mpool,pp->logand,cond);
  } else {
    cond=wg_first(db,cond);
  }
  if (conseqcount>1) {
    conseq=wg_inplace_reverselist(db,mpool,conseq);
    conseq=wg_mkpair(db,mpool,pp->logor,conseq);
  } else {
    conseq=wg_first(db,conseq);
  }
  if (!cond || !conseq) {
    wr_show_jsparse_error(g,pp,"failed to process if ... then ... construction: memory overflow");
    return NULL;
  }
  res=wg_mklist3(db,mpool,pp->logimp,cond,conseq);
  if (!res) {
    wr_show_jsparse_error(g,pp,"failed to process if ... then ... construction: memory overflow");
    return NULL;
  }
  return res;
}  


/*  

  & 
  to
  &

  (&)
  to
  &

  (& a)
  to 
  a

  (a & b)
  to 
  (& b a)

  (a & b & c)
  to
  (& (& c b) a)

  (a & b & c & d)
  to
  (& (& (& d c) b) a)

*/

void* wr_json_unflatten_logic(glb* g, parse_parm* pp, void* ptr, 
          void* conn, void* newconn, int ispos, int isreverse) {
  void* mpool=pp->mpool;            
  void* db=g->db;
  void *res,*a2,*a1r,*rst,*tmp;
   
  if (ptr==NULL) return NULL;
  if (wg_isatom(db,ptr)) {
    if (wr_json_equal_atoms(g,ptr,conn)) return NULL;
    else return wr_process_json_formula_aux(g,pp,ptr);
  }  
  rst=wg_rest(db,ptr);
  if (wr_json_equal_atoms(g,wg_first(db,ptr),conn)) {
    return wr_json_unflatten_logic(g,pp,rst,conn,newconn,ispos,isreverse);
  }
  if (rst==NULL) {      
    return wr_process_json_formula_aux(g,pp,wg_first(db,ptr));
  } 
  a1r=wr_json_unflatten_logic(g,pp,rst,conn,newconn,ispos,isreverse);
  a2=wg_first(db,ptr);
  if (wr_json_equal_atoms(g,a2,conn)) {
    return a1r;
  } else if (a1r==NULL) {
    return wr_process_json_formula_aux(g,pp,a2);
  } else {  
    a2=wr_process_json_formula_aux(g,pp,a2);
    if (ispos) {
      if (isreverse) res=wg_mklist3(db,mpool,newconn,a2,a1r);
      else res=wg_mklist3(db,mpool,newconn,a1r,a2);
    } else {
      tmp=wg_mklist3(db,mpool,newconn,a1r,a2);
      if (!tmp) {
        return NULL;
      }
      res=wg_mklist2(db,mpool,pp->logneg,tmp);
    }  
    return res;
  }         
}

void* wr_json_make_nullvar(glb* g, parse_parm* pp) {
  void* db=g->db;
  void* mpool=pp->mpool;
  int nr, found;
  void* atom;
  void* part;
  char buf[20];


  (pp->nullvarsnr)++;  
  for(; 1; (pp->nullvarsnr)++) {
    nr=pp->nullvarsnr;
    if (nr>10000) {
      wr_show_jsparse_error(g,pp,"failed to create a new variable for null");
      return NULL;
    }
    sprintf(buf,"%s%d",MPOOL_NULLVAR_PREFIX,nr);
    atom=wg_mkatom(db,mpool,WG_URITYPE,buf,NULL);

    if (wg_list_memberuri(db,(pp->freevars),atom)) continue;
    found=0;
    for(part=(pp->boundvars); part!=NULL; part=wg_rest(db,part)) {          
      if (wg_list_memberuri(db,wg_first(db,part),atom)) {
        found=1;
        break;
      }
    }
    if (found) continue;
    break;   
  }
  return atom;  
}

/* ------- convert clausified json clause to a record ------- */



void* wr_js_parse_clauselist(glb* g,void* mpool,cvec clvec,void* clauselist) {
  void* db=g->db;
  void* lpart;
  void* cl;
  int clnr=0;
  void *clause, *name, *role;
  void* record=NULL;
  void* resultlist=NULL;
  char** vardata;
  int i,len;
  void* propfun;
  void *frm, *flt, *fltpart, *context;
  gint cell;
  gcell *cellptr;
  
#ifdef DEBUG  
  DPRINTF("wr_js_parse_clauselist starting with clauselist\n");  
  wg_mpool_print(db,clauselist); 
  DPRINTF("\n");
#endif
   
  if (clvec!=NULL) CVEC_NEXT(clvec)=CVEC_START; 
  // create vardata block by malloc or inside mpool

  vardata=(char**)(wg_alloc_mpool(db,mpool,sizeof(char*)*VARDATALEN));
  if (vardata==NULL) {
    wr_show_parse_error(g,"cannot allocate vardata in wr_js_parse_clauselist");
    //(g->parse_errflag)=1;
    return NULL;
  }  
  //vardata=(char**)(malloc(sizeof(char*)*VARDATALEN));
  for(i=0;i<VARDATALEN;i++) vardata[i]=NULL; // pointers to varstrings  
  propfun=wg_mkatom(db,mpool,WG_URITYPE,PROPVAR_PREDSYMB,NULL);
  // loop over clauses  
  for(lpart=clauselist,clnr=0;wg_ispair(db,lpart);lpart=wg_rest(db,lpart),clnr++) {
    //if (clnr%10000==0) printf("clnr %d\n",clnr)
    if (g->parse_errflag) break;
    clause=wg_first(db,lpart);  
#ifdef DEBUG
    printf("\nclause in the wr_js_parse_clauselist loop:\n");
    wg_mpool_print(db,clause);
    printf("\n");
#endif
    context=NULL;
    if (!wg_ispair(db,clause)) {
      name=NULL;
      role=NULL;
      frm=clause;
    } else {
      len=wg_list_len(db,clause);
      if ((len!=3) && (len!=4)) {
        wr_show_parse_error(g,"clause in wg_parse_clauselist should have length 3 or 4");
        //(g->parse_errflag)=1;
        return NULL;
      }
      name=wg_nth(db,clause,0);
      role=wg_nth(db,clause,1);
      frm=wg_nth(db,clause,2);     
      if (len==4) context=wg_nth(db,clause,3);  
    }
#ifdef DEBUG     
    printf("\nin wr_js_parse_clauselist frm nr %d:\n",clnr);    
    wg_mpool_print(db,frm); 
    printf("\n");
#endif
    flt=wr_flatten_logclause(g,mpool,frm);
#ifdef DEBUG 
    printf("\nin wr_js_parse_clauselist got flt nr %d:\n",clnr);    
    wg_mpool_print(db,flt); 
    printf("\n");
#endif
    for(fltpart=flt; fltpart!=NULL; fltpart=wg_rest(db,fltpart)) {
      cl=wg_first( db,fltpart);
#ifdef DEBUG
      printf("\nin wr_parse_clauselist inner cl nr %d:\n",clnr);    
      wg_mpool_print(db,cl); 
      printf("\n");
#endif      
      record=wr_js_parse_clause(g,mpool,cl,clvec,vardata,propfun,name,role,context);    
      if (!record) continue; // parsing failed if NULL 
      // add record to the clauselist in db
      cell=alloc_listcell(db);
      if (!cell) {
        wr_show_parse_error(g,"failed to allocate a cell");
        //(g->parse_errflag)=1;
        return NULL;
      }  
      cellptr = (gcell *) offsettoptr(db, cell);
      (cellptr->car) = ptrtooffset(db, record);
      (cellptr->cdr) = (dbmemsegh(db)->clauselist);
      (dbmemsegh(db)->clauselist) = cell;       
      // add to resultlist, which is not really needed   
      resultlist=wg_mkpair(db,mpool,record,resultlist); // not really needed!!
      if (!resultlist) {
        wr_show_parse_error(g,"failed to add a clause to resultlist");
        //(g->parse_errflag)=1;
        return NULL;
      }
      // if clvec present, store record to clvec, given enough space
      if (clvec!=NULL) {
        if ((clvec[1]+1)<clvec[0]) {
          clvec[clvec[1]]=(gint)record; 
          ++(clvec[1]);
        } 
      }    
    }
  } // end clause list loop 
  DPRINTF("\nwr_js_parse_clauselist ending\n");
  //free(vardata); // if taken from mpool, not freed
  return resultlist;
}  

void* wr_js_parse_clause(glb* g,void* mpool,void* cl,cvec clvec,
        char** vardata,void* propfun, void* name, void* role, void* context) {
  void* db=g->db;
  void *clpart, *lit, *atom;
  int clnr=0;
  int litnr=0;
  int isneg=0;
  void *fun, *tmpptr, *atomres;
  gint ameta, tmpres2, setres, setres2, history;
  void* record=NULL;
  int issimple, i;
  void *termpart, *subterm;
  char *namestr, *rolestr;
  int rolenr;
  void* resultlist=NULL;

#ifdef DEBUG    
  printf("\n++ in wr_js_parse_clause clause is: %d\n",clnr);    
  wg_mpool_print(db,cl); 
  printf("\n");
  printf("\n++ in wr_js_parse_clause context is: \n");    
  wg_mpool_print(db,context); 
  printf("\n");
#endif    
  if (!wg_ispair(db,cl)) {    
    //show_parse_warning(db,"clause nr %d is atomic: ",clnr); 
    cl=wg_mklist1(db,mpool,cl);
#ifdef DEBUG      
    wg_mpool_print(db,cl); 
    printf("\n");    
    printf("\nCP1X\n");
#endif      
    //return NULL;
  }  
  // examine clause: find clause length and check if simple clause    
  issimple=1;
  litnr=0;
  for(clpart=cl;wg_ispair(db,clpart);clpart=wg_rest(db,clpart),litnr++) {
    if (g->parse_errflag) return NULL;
    lit=wg_first(db,clpart); 
#ifdef DEBUG      
    printf("\nlit: ");
    wg_mpool_print(db,lit); 
    printf("\n");      
#endif      
    if (!wg_ispair(db,lit)) { issimple=0; continue; }
    fun=wg_first(db,lit);
    if (wg_atomtype(db,fun)==WG_ANONCONSTTYPE && !strcmp(wg_atomstr1(db,fun),"not")) { issimple=0; continue; }
    for(termpart=lit;wg_ispair(db,termpart);termpart=wg_rest(db,termpart)) {
      subterm=wg_first(db,termpart);
#ifdef DEBUG        
      printf("\nsubterm: ");
      wg_mpool_print(db,subterm); 
      printf("\n");
#endif        
      if (subterm!=NULL && wg_ispair(db,subterm)) { issimple=0; break; }     
      if (wg_atomtype(db,subterm)==WG_VARTYPE) { issimple=0; break; } 
      if (wg_atomtype(db,subterm)==WG_URITYPE &&  
          ( (g->parse_caps_as_var && isupper(wg_atomstr1(db,subterm)[0])) ||
            (g->parse_question_as_var && wg_atomstr1(db,subterm)[0]=='?') )) {issimple=0; break;} 
    }      
  }        
  if (litnr>1) issimple=0;   
  // create record for a rule clause
  if (!issimple) {
    record=wr_create_rule_clause(g,litnr);   
    if (((gint)record)==0) {
      //free(vardata);
      return NULL;
    }
    resultlist=wg_mkpair(db,mpool,record,resultlist);       
  }  
  // clear vardata block for the next clause
  for(i=0;i<VARDATALEN;i++) {
    if (vardata[i]==NULL) break;
    vardata[i]=NULL;       
  }      
  // process one clause
  for(clpart=cl,litnr=0;wg_ispair(db,clpart);clpart=wg_rest(db,clpart),litnr++) {      
    if (g->parse_errflag) return NULL;
    lit=wg_first(db,clpart);
#ifdef DEBUG    
    printf("\nlit nr  %d:",litnr);    
    wg_mpool_print(db,lit); 
    printf("\n");
#endif      
    if (!wg_ispair(db,lit)) {        
      lit=wg_mkpair(db,mpool,propfun,wg_mkpair(db,mpool,lit,NULL));
      if (!lit) {
        //show_parse_warning(db,"failed to make a literal"); 
        wr_show_parse_error(g,"failed to make a literal");
        return NULL;
      }
      //show_parse_warning(db,"lit nr %d in clause nr %d is atomic and hence prefixed: ",litnr,clnr); 
      //wg_mpool_print(db,lit);
      //printf("\n");
#ifdef DEBUG        
      wg_mpool_print(db,lit); 
      printf("\n");
#endif        
      //continue;
    }               
    fun=wg_first(db,lit);
    if (!wg_isatom(db,fun)) {
      //show_parse_warning(db,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored: ",litnr,clnr); 
      wr_show_parse_error(g,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored: ",litnr,clnr);
#ifdef DEBUG        
      wg_mpool_print(db,fun); 
      printf("\n");
#endif        
      //continue;
      return NULL;
    }     
    isneg=0;
    if (wg_atomtype(db,fun)==WG_ANONCONSTTYPE && 
        !strcmp(wg_atomstr1(db,fun),"not") &&
        wg_atomstr2(db,fun)==NULL) {
      DPRINTF("detected negation");
      isneg=1;            
      tmpptr=wg_rest(db,lit);    
      if (!wg_ispair(db,tmpptr)) {          
        //show_parse_warning(db,"lit nr %d in clause nr %d does not contain proper atom after negation and hence ignored: ",litnr,clnr);         
        wr_show_parse_error(g,"lit nr %d in clause nr %d does not contain proper atom after negation and hence ignored: ",litnr,clnr);
#ifdef DEBUG          
        wg_mpool_print(db,lit); 
        printf("\n");
#endif          
        //continue;
        return NULL;
      } 
      atom=wg_first(db,tmpptr);
      if (!wg_ispair(db,atom)) {
        atom=wg_mkpair(db,mpool,propfun,wg_mkpair(db,mpool,atom,NULL));
        if (!atom) {
          //show_parse_warning(db,"failed to make an atom"); 
          wr_show_parse_error(g,"failed to make an atom"); 
          return NULL;
        }        
        //show_parse_warning(db,"lit nr %d in clause nr %d was atomic and is prefixed\n: ",litnr,clnr); 
#ifdef DEBUG          
        wg_mpool_print(db,lit); 
        printf("\n");
#endif          
        //continue;
      }
      fun=wg_first(db,atom);
      if (!wg_isatom(db,fun)) {
        //show_parse_warning(db,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored: ",litnr,clnr); 
        wr_show_parse_error(g,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored",litnr,clnr);
        //(g->parse_errflag)=1;
#ifdef DEBUG          
        wg_mpool_print(db,fun); 
        printf("\n");
#endif          
        //continue;
        return NULL;
      }         
    } else {
      atom=lit;
    }      
#ifdef DEBUG      
    DPRINTF("atom isneg %d: ",isneg);
    wg_mpool_print(db,atom);
#endif      
    // parse an atom in the clause
    atomres=wr_parse_atom(g,mpool,atom,isneg,issimple,vardata); 
    if (atomres==NULL) {
      wr_show_parse_error(g,"problem converting an atom to record");
      //(g->parse_errflag)=1;
      //free(vardata);
      return NULL;        
    }
    if (issimple) {
      wr_convert_atom_fact_clause(g,atomres,isneg);
      resultlist=wg_mkpair(db,mpool,atomres,resultlist);
      if (!resultlist) {
        //show_parse_warning(db,"failed to extend resultlist"); 
        wr_show_parse_error(g,"failed to extend resultlist"); 
        //(g->parse_errflag)=1;         
        return NULL;          
      }       
      record=atomres; // for storage of record in clvec
      break;        
    } else {     
      ameta=0;        
      if (isneg) ameta=(ameta | ATOM_META_NEG);      
      setres=wr_set_rule_clause_atom_meta(g,record,litnr,ameta);                
      tmpres2=wg_encode_record(db,atomres);
      setres2=wr_set_rule_clause_atom(g,record,litnr,tmpres2);
      if (setres!=0 || setres2!=0) {
        // wg_delete_record(db,atomres); // might leak memory
        free(vardata);
        return NULL; 
      }   
    }        
          
  } // end one clause processing loop
  // set history 
  if (name && wg_isatom(db,name) && wg_atomtype(db,name)==WG_URITYPE) {
    namestr=wg_atomstr1(db,name);
    if (!(namestr[0])) namestr=NULL;    
  } else {
    namestr=NULL;
  }  
  if (role && wg_isatom(db,role) && wg_atomtype(db,role)==WG_URITYPE) {
    rolestr=wg_atomstr1(db,role);        
    if (!strcmp("conjecture",rolestr) || !strcmp("negated_conjecture",rolestr)) {       
      rolenr=PARSER_GOAL_ROLENR;          
    } else if (!strcmp("hypothesis",rolestr) || !strcmp("assumption",rolestr)) {     
      rolenr=PARSER_ASSUMPTION_ROLENR;  
    } else if (!strcmp("axiom",rolestr) && 
             //  (g->parse_is_included_file) &&
             namestr!=NULL &&
             !strncmp(namestr,IMPORTED_NAME_PREFIX,strlen(IMPORTED_NAME_PREFIX)) ) {  
      rolenr=PARSER_EXTAXIOM_ROLENR;   
    } else {
      rolenr=PARSER_AXIOM_ROLENR; 
    }  
  } else {
    rolenr=PARSER_AXIOM_ROLENR;
  }      
  history=wr_build_input_history(g,record,namestr,rolenr);
  if (!history) {
    //show_parse_warning(db,"failed to make history"); 
    //return NULL;          
  } 
  //wr_set_input_history_ctxt(g,record,history,context); 
  wr_set_history(g,record,history); 
#ifdef DEBUG
  printf("\n built a record:\n");
  //wg_print_record(db_to_kb(db),record);
  wr_print_record(g,record);
  printf("\n");
#endif
  return record;
} 


/* ------------ errors ---------------- */


void json_err_printf2(char* s1, char* s2) {
  if (s1 && s2) printf("{\"error\": \"%s %s\"}\n",s1,s2);
  else if (s1) printf("{\"error\": \"%s\"}\n",s1);
  else if (s2) printf("{\"error\": \"%s\"}\n",s2);
  else printf("{\"error\": \"unspecified\"}\n");  
}

void json_err_printfn2(char* s1, int num, char* s2)  {
  printf("{\"error\": \"%s %d %s\"}\n",s1,num,s2);
}

void json_err_printf3(char* s1, int num, char* s2) {
  printf("{\"error\": \"%s %d %s\"}\n",s1,num,s2);
}


static int wr_show_jsparse_error(glb* g, parse_parm* pp, char* format, ...) {
  //void* db=g->db;
  int tmp1,tmp2;
  va_list args;
  va_start (args, format);
  /*
  printf("*** Parser error: ");
  vprintf (format, args);  
  va_end (args);
  printf("\n");
  */  

  if (g->parse_errflag) return -1;
  (g->parse_errflag)=1;  
  if (g->parse_errmsg) return -1;
  (g->parse_errmsg)=malloc(1000);
  if (!(g->parse_errmsg)) return -1;
  if (pp && pp->formulanr) {
    if (pp->formulaname) {
      tmp1=snprintf((g->parse_errmsg),50,
            "{\"error\": \"error in formula nr %d %s: ",pp->formulanr,pp->formulaname);
    } else {
      tmp1=snprintf((g->parse_errmsg),50,
            "{\"error\": \"error in formula nr %d: ",pp->formulanr);
    }  
  } else {
    tmp1=snprintf((g->parse_errmsg),50,"{\"error\": \"json parser error: ");
  }  
  tmp2=vsnprintf((g->parse_errmsg)+tmp1,800,format,args);
  snprintf((g->parse_errmsg)+tmp1+tmp2,50,"\"}");

  /*
  printf("{\"error\": \"parser error: ");
  vprintf (format, args);
  va_end (args);
  printf("\"}\n");
  */
  //exit(1);
  return -1;  
}