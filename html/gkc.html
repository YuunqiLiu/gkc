<!DOCTYPE html>
<html lang="en">
<head itemscope>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="description" content="Online logic solvers.">
<meta name="author" content="Tanel Tammet">
<meta name="keywords" content="logic, solvers, reasoning, propositions, dpll, resolution, truth table"> 

<meta itemprop="itemtype" content="http://schema.org/SoftwareApplication">
<meta itemprop="name" content="Logictools">
<meta itemprop="description" content="Logic solvers and conversion tools.">
<meta itemprop="url" content="http://logictools.org">
<meta itemprop="operatingSystems" content="Linux, Windows">
<meta itemprop="softwareApplicationCategory" content="WebApplication">

<meta property="og:title" content="Logictools"> 
<meta property="og:url" content="http://logictools.org"> 
<meta property="og:site_name" content="Logictools"> 
<meta property="og:type" content="website">
<meta property="og:description" content="Logic solvers and conversion tools.">
<meta property="fb:admins" content="tanel.tammet">

<link rel="shortcut icon" href="logo.png">

<title>Logictools</title>
<!-- Bootstrap core CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
<!-- Custom styles for this template -->
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet"> 
<link href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap" rel="stylesheet"> 
<link href="wdb.css" rel="stylesheet">
<style>
.result {
  padding: 15px; 
  white-space: pre-wrap;
}
.result_wiblock {
  padding: 0px; 
  color: black;
  font-family: 'Inconsolata','Roboto Mono','Courier New', Courier, monospace; 
} 

.syntax {  
  width: 70px; height: 30px; text-align: center; 
  padding: 0px 0px 1px 0px;  font-size: 12px;
  line-height: 1.42; border-radius: 15px; 
  background-color: #cccccc; color: #337ab7; margin-left: 15px;
}         

.btn-file {
  position: relative;
  overflow: hidden;
}
.btn-file input[type=file] {
  position: absolute;
  top: 0;
  right: 0;
  min-width: 100px;
  min-height: 100px;
  font-size: 100%;
  text-align: right;
  filter: alpha(opacity=0);
  opacity: 0;
  outline: none;
  background: white;
  cursor: inherit;
  display: block;
}

code {
    padding: .1em .4em;
    margin: 2px 5px 2px 5px;   
    font-size: 100%;
    color:black !important;
    background-color: #f4f4f4 !important;
    border-radius: 4px;
    font-family: 'Inconsolata','Roboto Mono','Courier New', Courier, monospace;
}

pre {    
    background-color: white !important;   
}

pre code {
    padding: 0 !important;
    margin: 0 !important;
    font-size: 100% !important;
    color: #222 !important;
    background-color: white !important;
    border-radius: 0 !important;
}

</style>
<script>
'use strict';

var gkcoutput="";

function useGkc(el) {
  var placeid;
  var input, output, textflag;
  var inputarea, outputplace;
  var arglist;
  var sel, conversion, print_level, print_derived, strategy, seconds;
 
  var placeid=el.parentNode.id;
  var div = document.getElementById(placeid+"_output"); 
  //clearOutputByPlace(placeid); 
  inputarea=document.getElementById("gkc_1_input");
  outputplace=document.getElementById("result");  
  input=inputarea.value;  
  if (seemsJson(input)) textflag="-jstext";
  else textflag="-text"   
  
  sel=document.getElementById("conversion_select");
  conversion=sel.options[sel.selectedIndex].value;
  if (conversion=="json" || conversion=="tptp") {
    arglist=[textflag,input,"-"+conversion];
  } else if (conversion=="simple" || conversion=="clauses") {
    arglist=[textflag,input];  
  } else {
    conversion=conversion.substring(8);        
    arglist=[textflag,input,"-"+conversion];
  }

  sel=document.getElementById("print_level");
  print_level=sel.options[sel.selectedIndex].value;
  arglist=arglist.concat(['-print',print_level]);

  sel=document.getElementById("print_derived");
  print_derived=sel.options[sel.selectedIndex].value;
  if (print_derived=="on") {
    arglist=arglist.concat(['-derived']);
  }

  sel=document.getElementById("strategy");
  strategy=sel.value;
  if (strategy) {
    arglist=arglist.concat(['-strategytext',strategy]);
  }

  sel=document.getElementById("seconds");
  seconds=sel.value;
  if (seconds) {
    seconds=parseInt(seconds);
    if (isNaN(seconds)) seconds=5;
    arglist=arglist.concat(['-seconds',""+seconds]);
  } else {
    arglist=arglist.concat(['-seconds',"5"]);
  }

  arglist=arglist.concat(['-parallel',"0"]);

  console.log(arglist);
  gkcoutput="";
  gkc(arglist);
  //console.log("gkcoutput",gkcoutput);
  document.getElementById("result").innerHTML=gkcoutput.trim();
}  

function seemsJson(str) {
  var c, len;
  var i,lpar=0,rpar=0,lbrack=0,lcurl=0,rcurl=0,rbrack=0,quotes=0,periods=0,perc=0;
  var tptpsymbs=0, jssymbs=0;
  
  if (!str) return 0;
  len=str.length;
  for(i=0; i<len; i++) {
    c=str[i];
    if (c=='[') lbrack++;
    else if (c==']') rbrack++;
    else if (c=='{') lcurl++;
    else if (c=='}') rcurl++;
    else if (c=='(') lpar++;
    else if (c==')') rpar++;
    else if (c=='"') quotes++;
    else if (c=='.') periods++;
    else if (c=='%') perc++;
  }
  if (!lbrack && !lcurl) return 0;
  if (!rbrack && !rcurl) return 0;
  if (!quotes) return 0;
  if (!periods && quotes) return 1;
  tptpsymbs=2*lcurl+2*rcurl+periods+perc;
  jssymbs=lbrack+rbrack+2*lcurl+2*rcurl+2*quotes;
  console.log(jssymbs,tptpsymbs);
  if (jssymbs>tptpsymbs) return 1;
  else return 0;
}

function gkc(arglist) {
  Module.callMain(arglist);
}  

function convert(el) {
  var placeid;
  var input, output, textflag;
  var inputarea, outputplace;
  var arglist;
  var conversion;
  var sel;

  var placeid=el.parentNode.id;
  var div = document.getElementById(placeid+"_output"); 
  //clearOutputByPlace(placeid); 
  inputarea=document.getElementById("gkc_1_input");
  outputplace=document.getElementById("result");  
  input=inputarea.value; 
  if (seemsJson(input)) textflag="-jstext";
  else textflag="-text"   

  sel=document.getElementById("conversion_select");
  conversion=sel.options[sel.selectedIndex].value;
  if (conversion=="json" || conversion=="tptp") {
    arglist=[textflag,input,"-convert","-"+conversion];
  } else if (conversion=="simple" || conversion=="clauses") {
    arglist=[textflag,input,"-clausify"];  
  } else {
    conversion=conversion.substring(8);        
    arglist=[textflag,input,"-clausify","-"+conversion];
  }  
  gkcoutput="";
  //console.log(arglist);
  gkc(arglist);
  //console.log("gkcoutput",gkcoutput);
  document.getElementById("result").innerHTML=gkcoutput;
}

function clearOutputByPlace(placeid) { 
  var div = document.getElementById(placeid+"_output");
  while(div.firstChild){
    div.removeChild(div.firstChild);
  }
}

function clearOutput(el) { 
  document.getElementById("result").innerHTML="";
  document.getElementById("proof_notes").innerHTML="";    
}

function clearInputByPlace(placeid) { 
  document.getElementById(placeid+"_input").value="";  
}

function clearInput(el) { 
  document.getElementById("gkc_1_input").value=""; 
  document.getElementById("input_notes").innerHTML="";  
}

function fillOutput(placeid,text) { 
  document.getElementById(placeid+"_output").innerHTML=text;  
}

// example selection

function selectExample(level) {
  var sel;
  var value;
  var data;
  var notes;
  var placeid,html,el;

  if (level=='simple') sel=document.getElementById("select_example");
  else sel=document.getElementById("select_advanced_example");
  value=sel.options[sel.selectedIndex].value;

  if (value=="examples") {
    document.getElementById("input_notes").innerHTML="";
    document.getElementById("proof_notes").innerHTML="";
    document.getElementById("result").innerHTML="";
    return;
  }
 
  placeid="example_"+value+"_";

  el=document.getElementById(placeid+"input_code");
  if (el) {
    html=el.innerHTML; 
    if (html) {
      html=html.replace(new RegExp("&amp;","g"),"&");
      html=html.replace(new RegExp("&gt;","g"),">");
      document.getElementById("gkc_1_input").value=html;
    }
  }
  if (!el || !html) document.getElementById("gkc_1_input").value="";

  el=document.getElementById(placeid+"input_notes");
  if (el) {
    html=el.innerHTML;
    if (html) {      
      document.getElementById("input_notes").innerHTML=html;
    }
  } 
  if (!el || !html) document.getElementById("input_notes").innerHTML=""; 

  el=document.getElementById(placeid+"proof_notes");
  if (el) {
    html=el.innerHTML;
    if (html) {
      document.getElementById("proof_notes").innerHTML=html;
    }
  }
  if (!el || !html) document.getElementById("proof_notes").innerHTML="";  

  html="<div class='click_prove'>Click the Prove button!</div>";
  html="<button onclick='useGkc(this); return false;' ";
  html+="class='btn btn-small btn-primary'style='width: 70px;''>Prove</button>";
  document.getElementById("result").innerHTML=html;
}

function switchAdvanced() {
  if ($('#advanced_buttons').is(":hidden")) {
    //$('#ctf_show_configuremenu').val('1');
    //$('#configure_btn').attr('value',clstr[2]);
  } else {
    //$('#ctf_show_configuremenu').val('0');
    //$('#configure_btn').attr('value',clstr[1]);
  }  
  $('#advanced_buttons').slideToggle('slow');
};

// simplified Module glue code originally produced by emscripten

var Module={  
  noInitialRun: true,
  preRun:[],
  postRun:[],
  print: function(s) {
    gkcoutput+=s+"\n";    
  },
  printErr:function(e){
    arguments.length>1 && (e=Array.prototype.slice.call(arguments).join(" "));
    if ((JSON.stringify(e)).includes("abort(OOM)")) {
      location.reload();
    } else if ((JSON.stringify(e)).includes("index out of bounds")) {
      location.reload();
    } else if ((JSON.stringify(e)).includes("timeout")) {
      location.reload();
    }
    console.error(e);    
  },
  setStatus:function(e){ return 1 },
  totalDependencies:0,
  monitorRunDependencies:function(e){
    this.totalDependencies=0; 
    Module.setStatus(e ? "Preparing... ("+(this.totalDependencies-e)+"/"+this.totalDependencies+")"
       : "All downloads complete.")
  }
};
/*
window.onerror=function(e){
  console.error(e);
  
  // Module.setStatus("Exception thrown, see JavaScript console"),
  // Module.setStatus=function(e){
  //   e && Module.printErr("[post-exception status] "+e)
  // }
  
}
*/
</script>
</head>

<body>

<div id="fb-root"></div>

<div class="navbar navbar-inverse navbar-static-top" style="background-color: #333333;">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Logictools</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="active"><a href="index.html">Solve predicate logic</a></li>        
        <li class="dummy"><a href="propositional.html">Solve propositional logic</a></li>
        <!-- <li class="dummy"><a href="predicate.html">Predicate logic</a></li> -->
        <li class="dummy"><a href="download.html">Download</a></li>        
        <li class="dummy"><a href="about.html">About</a></li> 
      </ul>
    </div><!--/.navbar-collapse -->
  </div>
</div>

<!-- content after titlebar -->


<div class="container">
  <div class="row">
    <div class="col-md-12 wblock wblock1">
    
    <!--------------------------- --->

<h2>Solve a predicate logic reasoning task: 
  <button type="button" class="btn btn-default" 
         onclick="gid('syntax').style.display='block'; document.location='#syntax'; "
         style="
          width: 70px; height: 30px; text-align: center; 
          padding: 0px 0px 1px 0px;  font-size: 12px;
          line-height: 1.42; border-radius: 15px; 
          background-color: #cccccc; color: #337ab7; margin-left: 15px;"
         >syntax</button>
</h2>                

  <div class="form-inline" method="post" osnubmit="return false;">
    <div class="wblock">      
      <div id="gkc_1">     
        <textarea class="form-control" id="gkc_1_input" spellcheck="false"
        style="height: 200px; width:100%; margin-bottom: 20px; color: black;
        font-family: 'Inconsolata','Roboto Mono','Courier New', Courier, monospace; ">% a simple example: using two facts and two rules, find a grandson of john

father(john,pete).
father(pete,mark).
(father(X,Y)  & father(Y,Z)) => grandfather(X,Z).
grandfather(X,Y) => grandson(Y,X).

grandson(X,john) => $ans(X).</textarea>
        <button onclick="useGkc(this); return false;" class="btn btn-small btn-primary"
        style="width: 70px;">Prove</button>
        <select class="form-control" style="width: 110px;" id="select_example"
          onchange="selectExample('simple')">
          <option value="examples">examples</option>
          <option value="1">basics</option>
          <option value="2">answers</option>
          <option value="3">rules</option>
          <option value="4">or-answers</option>
          <option value="5">more rules</option>
          <option value="6">functions</option>
          <option value="7">reflexivity</option>
          <option value="8">multiple answers</option>
          <option value="9">algebra</option>
          <option value="10">unprovable</option>
          <option value="11">hard</option>
          <option value="12">blocks world</option>      
        </select>
        &nbsp;or&nbsp;
        <span class="btn btn-default btn-file">
        Browse<input type="file" id="files" name="files"  
         value="">
        </span>    
        &nbsp;&nbsp;&nbsp;  
        <button onclick="convert(this); return false;" class="btn btn-small btn-primary"
        >Convert to</button>
        <select class="form-control" style="width: 110px;" id="conversion_select">
          <option value="simple">simple</option>
          <option value="json">json</option>
          <option value="tptp">tptp</option>
          <option value="clauses">simple clauses</option>
          <option value="clauses_json">json clauses</option>
          <option value="clauses_tptp">tptp clauses</option>          
        </select>
        &nbsp;&nbsp;&nbsp;
        <button onclick="clearOutput(this); switchAdvanced(); return false;" 
          class="btn btn-small btn-default"
        >Advanced</button>           
        &nbsp;&nbsp;&nbsp;            
        <button onclick="clearOutput(this); return false;" class="btn btn-small btn-default"
        >Clear result</button>
        <button onclick="clearInput(this); return false;" class="btn btn-small btn-default"
        >Clear input</button>
        <a href="#solveModal" data-toggle="modal" class="qlink">
          <button type="button" class="btn btn-default" style=" 
           width: 30px; height: 30px; text-align: center; padding: 6px 0;  font-size: 12px;
           line-height: 1.42; border-radius: 15px; 
           background-color: #cccccc; color: #337ab7; margin-left: 15px;">?</button>
        </a> 
        
        <div id="advanced_buttons" style="padding-top: 15px; display: none;">
          <div style="display: inline-block; width: 70px;">Advanced</div>
          <select class="form-control" style="width: 110px;" id="select_advanced_example"
            onchange="selectExample('advanced')">
            <option value="examples">examples</option>
            <option value="13">characters</option>
            <option value="14">TPTP FOF language</option>
            <option value="15">simple FOF language</option>
            <option value="16">strategy</option>
            <option value="17">arithmetic</option>
            <option value="18">lists</option>
            <option value="19">distinct symbols</option>                                
          </select>  
          <div style="display: inline-block; width: 70px;  margin-left: 15px;">Seconds</div>
          <input type="text" id="seconds" value="5" style="width: 50px"></input>
          <div style="display: inline-block; width: 70px;  margin-left: 15px;">Print level</div>
          <select class="form-control" style="width: 135px;" id="print_level">
            <option value="10">minimal</option>
            <option value="11">+ strategy</option>
            <option value="12">+ runs</option>
            <option value="15">+ statistics</option>
            <option value="20">+ given</option>
            <option value="40">+ derived</option>
            <option value="50">+ details</option>                       
            <option value="60">+ data structures</option> 
          </select>
          <div style="display: inline-block; width: 100px;  margin-left: 15px;">Show&nbsp;derived</div>
          <select class="form-control" style="width: 110px;" id="print_derived">
            <option value="off">off</option>
            <option value="on">on</option>                                  
          </select>
          <a href="#solveModal" data-toggle="modal" class="qlink">
            <button type="button" class="btn btn-default" style=" 
             width: 30px; height: 30px; text-align: center; padding: 6px 0;  font-size: 12px;
             line-height: 1.42; border-radius: 15px; 
             background-color: #cccccc; color: #337ab7; margin-left: 15px;">?</button></a>
          <p>              
          <textarea class="form-control" id="strategy" spellcheck="false"
           style="height: 100px; width:100%; margin-bottom: 20px; margin-top: 15px;"
           placeholder="Strategy as json text"></textarea>
        </div>
      </div>      
    </div>
    <p>                  
    </div>

<p>
<div id="input_notes"></div>
<p>
<h2>Result:</h2>

<div class="container">
  <div class="row">
    <div class="col-md-12 wblock wblock1">
        <div class="wiblock result_wiblock">  
          <div id="result" class="result"></div>
        </div>
    </div>
  </div>
</div>
<p>
  <div id="proof_notes"></div>
<p>

<!-- syntax description is initially hidden -->

<div id="syntax" style="display: none">
<h2>Syntax</h2> 

Use either a conventional formula syntax like
<pre>
(a -&gt; b) &amp; a &amp; -b
</pre>
or a <a href="http://www.domagoj-babic.com/uploads/ResearchProjects/Spear/dimacs-cnf.pdf">dimacs</a> 
version of the clause normal form syntax like
<pre>
-1 2
1
-2
</pre>
which is a conjunction of disjunction lines with numbers standing for variables:
the last example means simply <tt>(-x1 v x2) &amp; x1 &amp; -x2</tt>
<p><p>
For conventional formula syntax:
<ul>
<li>negation symbols are <b>-, ~</b></li>
<li>conjunction symbols are <b>&amp;, and</b></li>
<li>disjunction symbols are <b>|, v, V, or</b></li> 
<li>xor symbols are <b>+, xor </b></li>
<li>implication symbols are <b>-&gt;, =&gt;</b></li> 
<li>equivalence symbols are <b>&lt;-&gt;, &lt;=&gt;</b></li> 
</ul>
There is no operator precedence; all operators are bound from left:<br>
<tt>a &amp; b v c &amp; d v e</tt>  is read as <tt>((((a &amp; b) v c) &amp; d) v e)</tt>
<p><p>
For dimacs you may use or skip the initial comment lines starting with <b>c</b>,
the special <b>p</b> line and the final <b>0</b> symbols at the end of each disjunct.
We allow the trailing <b>0</b>-s only at the end of a line.
<p>
I.e. you may use the full dimacs version like
<pre>
c comment
p cnf 2 3
-1 2 0
1 0
-2 0
</pre>
or just
<pre>
-1 2
1
-2
</pre>


<a href="#" onclick="gid('syntax').style.display='none';">hide syntax</a>
</div>
    
    <!-------------------------- --->
    </div>
  </div>
</div>

<!-- footer -->
<!--
<div class="ofooter">  
  <div class="col-md-12 container ifooter">
  </div>  
</div> 
-->
<div style="height:50px; width: 100%"> </div>

<!-- modal help texts --->


<div class="modal fade" id="solveModal" tabindex="-1" role="dialog" 
    aria-labelledby="solveModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content modal_login">        
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
            <span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="solveModalLabel" style="color: black;">Solve a propositional formula</h4>
      </div>
      <div class="modal-body">                        
        <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">Solving</a> a classical
        <a href="http://en.wikipedia.org/wiki/Propositional_calculus">propositional formula</a>
        means looking for such values of variables that the formula becomes true. For example,
        <tt>(a -&gt; b) &amp; a</tt> becomes true if and only if both <tt>a</tt> and <tt>b</tt> are assigned true. 
        <p><p>
        You can select and try out several solver algorithms: 
        the "<a href='http://en.wikipedia.org/wiki/DPLL_algorithm'>DPLL</a> better" 
        is the best solver amongst the options. 
        <a href="propositional.html">Read from here</a> about the differences between algorithms.
        <p>
        One single suitable set of values
        is enough as a solution: the solver algorithms stop and do not try to find additional solutions. Some of the solver algorithms
        output the suitable values, but some do not, or output a partial set.
        <p>
        It may also happen that the formula is false for all possible values of variables: if so, the solver algorithms report
        that after exhausting the search options. For example,
        <tt>(a -&gt; b) &amp; a &amp; -b</tt> is always false.
        <p>
        Notice that you can check whether some formula <i>F</i> is always true by trying to solve the 
        <b>negated</b> formula <i>-F</i>: in case <i>-F</i> is always false, <i>F</i> must be always true.
        <p>      
        The algorithms may optionally output a trace of the search process. Select "html trace" to see the search
        process: again, read <a href="propositional.html">from here</a> about the search methods used by the
        algorithms.
        <p>
        For formula-syntax input the solvers first convert the formula to a 
        <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form">clause normal form</a>: for certain kinds of formulas this
        conversion step may create a huge output, but in most cases it is a sensible simplification before actual search.
        <p>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->


<div class="modal fade" id="buildModal" tabindex="-1" role="dialog" 
    aria-labelledby="buildModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content modal_login">        
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
            <span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="buildModalLabel">Build</h4>
      </div>
      <div class="modal-body">                        
        The three building options "truth table", "clause normal form" and a "parse tree" are simple,
        useful utilities:
        <p><p>
        <ul>
        <li>
        The <b>truth table</b>
        prints a full  
        <a href="http://en.wikipedia.org/wiki/Truth_table">truth table</a> 
        of a formula up to 1024 rows: nice for checking out
        small propositional formulas.
        <p>
        </li><li>
        The <b>clause normal form</b> is a 
        <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form</a> just as used by
        the solvers. The conversion algorithm used is very simple and does not perform any optimizations. In many
        cases the optimized converters like the 
        <a href="http://en.wikipedia.org/wiki/Tseitin_transformation">Tseitin transformation</a> 
        would give a much smaller output much faster.
        <p>
        </li><li>
        The <b>parse tree</b> prints a formula as a nested list built by the simple
        <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>. 
        This list is later used by the
        clause normal form converter to build the form suitable for solvers. Check the parse tree in case you are
        not sure how the system understands your formula.
        </li>
        </ul>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->


<div class="modal fade" id="generateModal" tabindex="-1" role="dialog" 
    aria-labelledby="generateModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content modal_login">        
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
            <span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="generateModalLabel" >Generate a problem</h4>
      </div>
      <div class="modal-body">                        
        <b>Generate a problem</b> will generate an example problem in a simple 
        <a href="http://www.domagoj-babic.com/uploads/ResearchProjects/Spear/dimacs-cnf.pdf">DIMACS format</a>
        of a clause normal form, suitable for solvers.
        <p><p>
        The options for the type of a problem are:
        <ul>
          <li><b>random 3-sat</b> generates a random set of 
          <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability">clauses of length 3</a>,
          using the number of
          variables you choose: problems containing more variables are, on the average, harder to solve.
          The number of clauses is always four times the number of variables: this
          is, on the average, a specially hard-to-solve ratio for solvers.
          <p><p>For DPLL try out 200 variables or
          more. Truth table solvers start running into trouble with more than 20 variables. The resolution
          provers are a bit better than the truth table solvers, yet much worse than the DPLL solvers.</li>
          <li><b>all combinations</b> generates a set of clauses representing all possible combinations 
          of the input variables: any such set is unsatisfiable (i.e. no values of variables can make it true).
          The number of clauses is hence always two to the power of the number of variables.</li>
          <li><b>small unsat</b> generates a very small unsatisfiable clause set, consisting of a single long
          clause containing all the variables and N single-element clauses containing all variables negated.</li>
        </ul>
        The <b>clear</b> button simply clears the input field and result.
        <p>
        You can also <b>browse</b> and read the contents of a file into the input area: essentially copy-paste from
        a file.        
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- raw examples text -->

<div hidden>

<div id="example_1_input_notes"><h3>Example 1 for basics</h3>

<p>This is a really trivial example.</p>

<p>We will give two facts: <i>john is a father of pete</i> and
<i>pete is a father of mark</i>. We will ask whether from these
two facts we can derive that <i>john is a father of pete</i>: 
obviously we can.</p>

<p>The facts and the question are written in predicate logic, with the
question posed as a negation, from which gkc derives contradiction.</p>

<p>Why the negation and contradiction? This is just a convenient way to simplify
the problem. Here we really want to prove <code>a &amp; b =&gt; a</code>. This is true
if and only if <code>-(a &amp; b =&gt; a)</code> is false. Now, the last formula 
is equivalent to <code>a &amp; b &amp; -a</code>. Thus 
the input facts and rules stay as they are, and we only negate the conclusion to be proved.
To summarize, giving
a goal to be proved from axioms (i.e. known facts / rules) as a negated 
statement is just a convenient way to organize proof search and there is nothing really
special about it.</p>

</div>

<pre><code id="example_1_input_code">father(john,pete).
father(pete,mark).

-father(john,pete).

% What this means?
% We want to prove that from the first two facts the third is derived.
% To do so, we prove that if we negate the third (the conclusion),
% the conjunction of all the facts gives a contradiction.</code></pre>


<p>Notice that each statement in the input file is terminated with a period sign.
The list of statements is assumed to be a conjunction (<i>and</i>) of all statements. 
Minus sign - means negation. Thus <code>-father(john,pete)</code> means 
<i>john is NOT the father of pete</i>.</p>

<p>Percentage character % is a line comment. Multi-line comments <code>/* .... */</code>
can be used as well. </p>

<p>The order of statements is not really important, although it may cause minor
and essentially unpredictable differences in search behaviour. Essentially, gkc
creates and tries out its own search strategies, like SQL databases. It does not
follow a pre-determined predictable search strategy like PROLOG.</p>

<div id="example_1_proof_notes">

<p>The output first indicates that the proof was found.
<p>The <code>proof</code> block gives us numbered steps of the proof found:
each step is either a used input fact / rule or a derived fact / rule.</p>

<p>The [in] means that this fact/rule was given in input.</p>

<p>The [mp, 1, 2] (not exactly present in this proof) means that this fact / rule 
was derived by modus ponens (i.e. the 
<a href="https://en.wikipedia.org/wiki/Resolution_(logic)">resolution rule</a>)
from previous steps 1 and 2. More concretely, the first literals of both were cut off and
the rest were glued together.</p>

<p>The [simp, 1, 2] means the same as the [mp,...] above, just a specially simple case.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Resolution_(logic)">Resolution (logic) wiki page</a> 
is a good short intro to the general principles of the derivation rules with the 
<a href="http://lambda.ee/w/images/0/06/Geoffreasoningnotes.pdf">course materials of Geoff Sutcliffe</a> 
being a suitable continuation towards deeper understanding. However, the following examples are understandable without in-depth theoretical background.</p>

<p>Try to modify the example by removing the statement <code>-father(john,pete).</code> and
run the prover again. After ca one second it will stop and output</p>

<pre><code>result: proof not found.
</code></pre>

<p>Although the task is trivial, gkc does not attempt to be clever and tries out a large number
of search strategies: this is why it takes a second to terminate. You can try running gkc
with the optional switch producing more information to see the whole process: click
on the <i>Advanced</i> button and select a higher print level or set the <i>Show derived</i>
to <i>on</i></p>

<p>In case gkc does not understand the syntax of the input file it will give a json-formatted
error indicating a culprit line and piece of input like this:</p>

<pre><code>{"error": "syntax error, unexpected URI, expecting '.': file example1.txt place 'as' in line 3:
foo bar ("}
</code></pre>

</div>

<div id="example_2_input_notes"><h3>Example 2 for answers</h3>

<p>Like example 1, but we want to find a concrete person as an answer: we use the special
<code>$ans</code> predicate for this. Observe the <code>answer: $ans(pete).</code> line in the output
stemming from this answer predicate.</p>

<p>We are using a variable here: any word starting with a capital letter is considered
to be a variable. <code>X</code> is a variable in our example. You could also use, say <code>Something</code>
as a variable: it also starts with a capital letter. All the words starting with
a non-capital letter are constants, functions or predicates.</p>

<p>Vertical bar <code>|</code> is logical <i>or</i>. </p>

<p>Importantly, any rule like <code>a &amp; b =&gt; c</code> can be represented
as a <i>clause</i> <code>-a | -b | c</code> where negated atoms are essentially on the left side of the implication
and the positive atoms on the right side. For example, <code>-a | -b | c | d</code> is equivalent
to <code>(a &amp; b) =&gt; (c | d)</code>. You can use =&gt;, &lt;=&gt; and quantifiers directly like
in <code>-father(john,X) => $ans(X)</code> or as an equivalent clause in the example.

</div>

<p>Input file example2.txt:</p>

<pre><code id="example_2_input_code">father(john,pete).
father(pete,mark).

-father(john,X) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example2.txt
by run 2 fork 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}

answer: $ans(pete).
proof:
 1: [in, axiom] father(john,pete).
 2: [in, axiom] -father(john,X) | $ans(X).
 3: [mp, 1, 2, fromaxiom] $ans(pete).
</code></pre>

<div id="example_2_proof_notes">
<p>Notice that gkc outputs a line <code>answer: $ans(pete).</code> indicating the substitution
made for <code>X</code>: pete is the answer we were looking for.</p>

<p>Modify the example and try out the line</p>

<pre><code>-father(Y,X) | $ans(Y,X).
</code></pre>

<p>You will get <code>answer: $ans(john,pete).</code> in the output.
It is possible to force gkc to give more answers than just one: more
about that later.</p>
</div>

<div id="example_3_input_notes"><h3>Example 3 for rules</h3>

<p>Now we add a grandfather rule and ask for a grandchild of John.</p>

</div>
<p>Input file example3.txt:</p>

<pre><code id="example_3_input_code">father(john,pete).
father(pete,mark).

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
-father(X,Y) | -father(Y,Z) | grandfather(X,Z).

-grandfather(john,X) | $ans(X).
</code></pre>


<div id="example_4_input_notes"><h3>Example 4 for indefinite answers</h3>

<p>Let us make it unclear which sons pete actually has.</p>

</div>
<p>Input file example4.txt:</p>

<pre><code id="example_4_input_code">father(john,pete).

% either the first or a second or both facts are true:
father(pete,mark) | father(pete,mickey).

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
-father(X,Y) | -father(Y,Z) | grandfather(X,Z).

-grandfather(john,X) | $ans(X).
</code></pre>

<div id="example_4_proof_notes">

<p>Indeed, there is no way to give a definite answer, but gkc gives a correct answer indicating
that either mark or mickey is a grandson of john, or perhaps both are.</p>

<p>The [mp, 1.2, 2, fromaxiom] means that the 2th (numeration 0,1,2,...) literal in the clause at proof step 1 
was cut off with the first (0th) literal of the clause at proof step 2. In case the first literal is cut off,
the N.0 is simplified to N, as in the previous examples.</p>

<p>I.e. literals in a clause are numbered 0, 1, 2, etc and the number 0 is not added to the step number.</p>
</div>

<div id="example_5_input_notes"><h3>Example 5 for more rules</h3>

<p>To make matters a bit more complicated, we add an ancestor rule 
and look for ancestors of mark.</p>

</div>
<p>Input file example5.txt:</p>

<pre><code id="example_5_input_code">father(john,pete).
father(pete,mark).

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
-father(X,Y) | -father(Y,Z) | grandfather(X,Z).
-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).
-father(X,Y) | ancestor(X,Y).

-ancestor(X,mark) | $ans(X).
</code></pre>

<div id="example_5_proof_notes"></div>

<div id="example_6_input_notes"><h3>Example 6 for equalities and functions</h3>

<p>Now we reformulate the whole thing with equalities and functions! </p>

<p>father(john)=pete means, as expected, that pete is the father
of john and there can be no other fathers. If you also gave
father(john)=lucas this would make gkc to conclude that
pete and lucas are the same object, i.e. pete=lucas.</p>

<p>Importantly, two different constants are not considered inequal
by default (think of the constants as labels on objects: there could
be several different labels on one object):
<code>a=b</code> does not give a contradiction.</p>

<p>Notice that the following proof does not use equalities, just functions.</p>
</div>

<pre><code id="example_6_input_code">% previously we had father(john,pete).
father(john)=pete.
%previously we had father(pete,mark).
father(pete)=mark.
% previously we had -father(X,Y) | -father(Y,Z) | grandfather(X,Z).
grandfather(father(father(X)),X).
-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).
ancestor(father(X),X).
-ancestor(X,mark) | $ans(X).</code></pre>

<div id="example_6_proof_notes">
<p>See that gkc was happily answering <code>father(mark)</code> although we have
not said who the father of mark actually is! The functions like <code>father</code> 
do not have to be defined on all the possible objects, they can be partially
known and partially unknown.</p>
</div>


<div id="example_7_input_notes"><h3>Example 7 for reflexivity</h3>
Here we directly ask for a father of a father of John.
</div>

<pre><code id="example_7_input_code">% previously we had father(john,pete).
father(john)=pete.
% previously we had father(pete,mark).
father(pete)=mark.
% previously we had -father(X,Y) | -father(Y,Z) | grandfather(X,Z).
grandfather(father(father(X)),X).
-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).

father(father(john)) != X | $ans(X).</code></pre>

<div id="example_7_proof_notes">
<p>Here the proof uses the reflexivity rule <code>r=</code> which is basically the
standard property of equality: <code>X=X</code>.</p>
</div>

<div id="example_8_input_notes"><h3>Example 8 for multiple answers</h3>

<p>Now let us look at how to get several answers, not just one.
We will also introduce mothers and a mother-side grandfather
rule.</p>

We will use a separate json-syntax strategy text
to tell gkc specific details of what
to look for and how.</p>

Please click on the <b>Advanced</b> button above and copy-paste the multineg.txt json 
into the <b>Strategy</b> box, then click <b>Prove</b>.
<p>
<pre><code>{
"max_answers":2,
"strategy": ["negative_pref"]
}
</code></pre>

<p>The <code>"max_answers":2</code> part tells gkc that it should
try to find at least 2 answers and stop after that.</p>

<p>The <code>"strategy": ["negative_pref"]</code> indicates that one specific
strategy (here a conventional negative-preference ordered binary resolution)
is to be used for proof search, without any parallel or sequential attempts
with different search strategies.</p>
</div>
<pre><code id="example_8_input_code">
father(john) = pete.
father(mike) = pete.
mother(john) = eve.
mother(mike) = eve.

father(pete) = mark.
mother(eve) = mary.

grandfather(father(father(X)),X).
grandfather(father(mother(X)),X).

-grandfather(mark,X) | $ans(X).</code></pre>

<div id="example_8_proof_notes">
<p>The <code>[=, 1, 2.0.2, fromaxiom]</code> means that the clause at step 1 was used to replace a 2th subterm
(numbering 0,1,2,...) of the 0th atom of a clause at step 2 using equality.</p>

<p>Observe that the two answers have (obviously) different proofs.</p>

<p>Try to modify the strategy into ask for three answers: "max_answers":3,
and then run gkc again. It will give the same output as before, but will add the 
last line at the end:</p>

<pre><code>result: proof not found.
</code></pre>

<p>essentially indicating that the required number of different proofs (3) were not found.  </p>
</div>

<div id="example_9_input_notes"><h3>Example algebra</h3>

<p>Next we will take a question from abstract algebra,
axiomatized wholly by equalities.</p>
</div>
<pre><code id="example_9_input_code">% A question from abstract algebra. Here m is an arbitrary binary
% operation (similar to arithmetic multiplication) for 
% which the following three axioms hold.

m(X,i(X)) = e .   % i is an inverse function like one divided by X
m(X,e) = X .      % e is a unit element like 1 when on the right side
m(X,m(Y,Z)) = m(m(X,Y),Z) . % m is an associative operation

% Question: is e also a unit element when it is on the left
% side of multiplication m?
%
% We get the following clause by negating `forall X. m(e,X) = X`
% as `exists X. m(e,X) != X`
% and using an arbitrary unknown constant `c` for existentially 
% quantified `X`.
% In short, if the next clause gives contradiction, then it will
% also give a contradiction for anything you can put in place of `c`.

m(e,c) != c .
</code></pre>

<div id="example_9_proof_notes">
<p>The proof uses given equalities to derive several new equalities.
The <code>=</code> rule basically replaces parts of one premiss matching (unifying)
one side of the second premiss equality with the other side of the equality.</p>

<p>The <code>simp</code> rule also replaces a part of a premiss, but does so by <i>rewriting</i>,
meaning that the original unchanged premiss is not used in the search after
the simplification replacement.</p>

<p>The <code>[=, 1, 2.0.3, fromaxiom]</code> line means that the clause at step 1 was used to replace a 3th subterm
(numbering 0,1,2,...) of the 0th atom of a clause at step 2 using equality.</p>

</div>

<div id="example_10_input_notes"><h3>Example with an unprovable problem</h3>

<p>A simple clause set in this example produces an unlimited number of clauses like</p>

<pre><code>p(f(a))
p(f(f(a)))
p(f(f(f(a)))
...
</code></pre>

<p>and obviously does not lead to a contradiction.</p>

<p>However, gkc does not attempt to detect unprovability and will
run either forever or for a very long time, until the browser complains
and asks you to stop, or it runs out of allocated time or memory.</p>
<p><b>NB!</b> You will have to <b>reload</b> the page after you stop the script, otherwise
the page will be unresponsive.</p>

<p>
It is a good idea to click on the <b>Advanced</b> button and enter a sensible
time limit to the <b>Seconds</b> box.
</div>

<pre><code id="example_10_input_code">p(a).
-p(X) | p(f(X)).
  </code></pre>

<div id="example_10_proof_notes"></div>

<div id="example_11_input_notes"><h3>Example with a hard problem</h3>

<p>As an example of a small but a really hard problem for gkc which is
nevertheless actually provable, try the problem 
<a href="http://www.tptp.org/cgi-bin/SeeTPTP?Category=Problems&Domain=LCL&File=LCL876+1.p">LCL876+1</a>
from the <a href="http://www.tptp.org/">TPTP</a> collection.

<p>It will probably run until the browser complains badly 
or time given by the automatic strategy selection runs out.</p>

<p><b>NB!</b> You will have to <b>reload</b> the page after you stop the script, otherwise
  the page will be unresponsive.</p>  

<p>Of course, it is likely that with a suitable search strategy
gkc will find a proof using a sensible amount of time and memory. Currently
we are simply unaware of which strategy it would be!</p>
</div>

<pre><code id="example_11_input_code">(is_a_theorem(implies(X,Y)) & is_a_theorem(X)) => is_a_theorem(Y).
is_a_theorem(implies(X,implies(Y,X))).
is_a_theorem(implies(implies(X,Y),implies(implies(Y,Z),implies(X,Z)))).
is_a_theorem(implies(implies(implies(X,Y),Y),implies(implies(Y,X),X))).
is_a_theorem(implies(implies(not(X),not(Y)),implies(Y,X))).
is_a_theorem(implies(implies(implies(X,Y),implies(Y,X)),implies(Y,X))).
</code></pre>

<div id="example_11_proof_notes"></div>

<div id="example_12_input_notes"><h3>Blocks world</h3>

<p><a href="https://en.wikipedia.org/wiki/Blocks_world">Blocks world</a>
is a classic family of toy problems: there is a robot arm
able to lift single blocks and to put them on top of other blocks.</p>

<p>The goal is to find a sequence of robot arm movements to produce
a required configuration of blocks: for example, a tower.</p>

<p>Without a specialized search strategy these planning problems
tend to be surprisingly hard for provers, including gkc.</p>
</div>
<pre><code id="example_12_input_code">% -----------------------------------
%
% See https://en.wikipedia.org/wiki/Blocks_world
% 
% -----------------------------------

% ----- initial situation s0 ------
%
%           c 
%   a   b   d
%  ------------------------------

holds(on(a,table),s0).
holds(on(b,table),s0).
holds(on(c,d),s0).
holds(on(d,table),s0).
holds(clear(a),s0).
holds(clear(b),s0).
holds(clear(c),s0).
holds(empty,s0).
holds(clear(table),State).

% ---- difference of objects -----

    
differ(X,Y)
    | -differ(Y,X).

differ(a,b).
differ(a,c).
differ(a,d).
differ(a,table).
differ(b,c).
differ(b,d).
differ(b,table).
differ(c,d).
differ(c,table).
differ(d,table).

% ----- pickup rules  ------

holds(holding(X),do(pickup(X),State))
    | -holds(empty,State)
    | -holds(clear(X),State)
    | -differ(X,table).

holds(clear(Y),do(pickup(X),State))
    | -holds(on(X,Y),State)
    | -holds(clear(X),State)
    | -holds(empty,State).

% --- frame axioms for pickup ----
%
% see https://en.wikipedia.org/wiki/Frame_problem
% 

holds(on(X,Y),do(pickup(Z),State))
    | -holds(on(X,Y),State)
    | -differ(X,Z).

holds(clear(X),do(pickup(Z),State))
    | -holds(clear(X),State)
    | -differ(X,Z).

% ---- putdown rules -----

holds(empty,do(putdown(X,Y),State))
    | -holds(holding(X),State)
    | -holds(clear(Y),State).

holds(on(X,Y),do(putdown(X,Y),State))
    | -holds(holding(X),State)
    | -holds(clear(Y),State).

holds(clear(X),do(putdown(X,Y),State))
    | -holds(holding(X),State)
    | -holds(clear(Y),State).

% ---- frame axioms for putdown -----
%
% see https://en.wikipedia.org/wiki/Frame_problem
% 

holds(on(X,Y),do(putdown(Z,W),State))
    | -holds(on(X,Y),State).    

holds(clear(Z),do(putdown(X,Y),State))
    | -holds(clear(Z),State)
    | -differ(Z,Y).

% ----- query 1 -----------------
%
% build a tower:
%
%   c
%   b        
%   a   
%
% ------------------------------- 


-holds(on(b,a),State) | -holds(on(c,b),State) | $ans(State).


% ----- query 2 -----------------
%
% this is a harder problem: to try it out,
% comment out query 1 and uncomment the following
%
% build a tower:
%
%   c
%   b        
%   a   
%   d
% -------------------------------


% cnf(prove,negated_conjecture,
%   -holds(on(a,d),State) | -holds(on(b,a),State) | -holds(on(c,b),State) | $ans(State)).   
  
  
% ----- query 3 -----------------
%
% this harder problem is a case of Sussman anomaly
% https://en.wikipedia.org/wiki/Sussman_anomaly :
% to try it out,
% comment out queries 1 and 2 and uncomment the following
%
% build a tower:
%
%   b
%   a        
%   d   
%   c
% -------------------------------


%cnf(prove,negated_conjecture,
%   -holds(on(d,c),State) | -holds(on(a,d),State) | -holds(on(b,a),State) | $ans(State)). 
</code></pre>

<!--
<div id="example_14_input_notes"><h3>Example 14 for</h3>
intro 14 
</div>
<pre>
<code id="example_14_input_code">code 14
</code>
</pre>
<div id="example_14_proof_notes">
note 14
</div>

<div id="example_14_input_notes"><h3>Example 14 for</h3>
intro 14 
</div>
<pre>
<code id="example_14_input_code">code 14
</code>
</pre>
<div id="example_14_proof_notes">
note 14
</div>
-->

<div id="example_13_input_notes"><h3>Example 13 for various characters</h3>

<p>This is not a really advanced topic, but important. 
</p>

<p>Gkc follows the
<a href="http://tptp.org/TPTP/TR/TPTPTR.shtml#FormulaeSection">TPTP conventions</a> 
in the way it treats special characters, with a few
additions. A normal symbol must not contain any whitespace or non-alphanumeric characters
like (, -, ~, =, ", comma etc: however, underscore _ and dollar $ are allowed, with
predicates and functions with a special predefined meaning being prefixed
with a dollar $.</p>

<p>You can put whitespace or any symbol (single quotes inside quoted
symbols must be prefixed by a backslash) into symbols by surrounding the symbol 
with single quote symbols like this: 
<code>'John \'Smith\'!'</code> which is treated as a constant, despite that
it starts with a capital letter inside the quotes.

<p>Any symbol containing a character except an ascii letter, digit, underscore _,
or dollar $ will be printed out by surrounding it with single quotes.
As an exception in gkc, equality = and conveniece infix forms of
arithmetic expressions +, *, -, /, will not be surrounded by quotes. </p>

<p><i>Double quotes</i> like <code>"John Smith"</code> indicate that
a symbol is <i>distinct</i>, i.e. unequal to any other distinct symbol,
number or a typed object. Double quotes inside double quoted symbols must
be prefixed by a backslash. More about distinct symbols in the later examples.</p>

<p>Additionally gkc allows to make a symbol variable by prefixing it with a question
mark like this: <code>?smth</code>. Any symbol starting with a capital letter or a question mark 
is assumed to be a variable, and the rest are not. </p>

<p>This holds for both the simple syntax in the previous examples and the 
TPTP <i>fof</i> formulas to be described next. </p>

<p>Thus, for gkc in <i>fof</i> formulas a capital-letter-starting symbol is a 
<i>free</i> variable even if
it is not explicitly quantified: since this could be confusing, it
may be better to avoid such symbols unless they are explicitly quantified.</p>

<p>You can also use integers like 71 or period-separated decimals like 1.35
as constants.</p>

<p>Gkc is agnostic towards using different character encodings: it uses
c-strings, i.e. 0-terminated byte sequences and does not care about encodings.</p>

</div>
<pre>
<code id="example_13_input_code">p('John \'Smith\'!').
p(X) => $ans(X).
</code>
</pre>
<div id="example_13_proof_notes">
</div>

<div id="example_14_input_notes"><h3>Example 14 for TPTP syntax with steam</h3>

This example is a classic "Schubert's Steamroller" puzzle taken from
TPTP and written in fof syntax with connectives like implication as <code>=&gt;</code>, 
quantifiers <i>for all</i> as <code>! [X] ..,</code>, <i>exists</i> as 
<code>? [X] ... </code> etc.
<p>
The full list of infix binary connectives follows the TPTP language:
<ul>
<li><code>"|"</code> for disjunction,
<li><code>"&"</code> for conjunction, 
<li><code>"&lt;=>"</code> for equivalence, 
<li><code>"=>"</code> for implication, 
<li><code>"&lt;="</code> for reverse implication, 
<li><code>"&lt;~>"</code> for non-equivalence (XOR), 
<li><code>"~|"</code> for negated disjunction (NOR), 
<li><code>"~&"</code> for negated conjunction (NAND), 
<li><code>"@"</code> for application, used mainly in the higher-order context in TPTP.
</ul>
<p>
See the official <a href="http://tptp.org/TPTP/TR/TPTPTR.shtml#FormulaeSection">fof syntax</a> and
<a href="http://www.tptp.org/cgi-bin/SeeTPTP?Category=Problems&amp;Domain=SYN&amp;File=SYN000+1.p">fof example</a>
in <a href="http://www.tptp.org">TPTP</a>.</p>

<p>Gkc will first convert the complex formulas to a simple clause form (properly called
<i>clause normal form</i>) used in the previous examples. The statements we had in these
examples are called <i>clauses</i>. </p>

<p>Each statement in the <i>TPTP fof language</i> 
  is terminated with a period symbol . and has a structure</p>

<pre><code>fof(statement_name, statement_role, statement).
</code></pre>

<p>where the statement <i>name</i> will be used in the proof, the statement <i>role</i> indicates whether
it is an axiom, an assumption or hypothesis, or a goal to be proved from these: the latter is either
conjecture (which has to be negated) or negated_conjecture (negated already).</p>

<p>Indicating the role enables provers to find a more suitable strategy. It does not (except the
conjecture case, which has to be negated) have a <i>logical</i> meaning.</p>

<p>The first formula in the example is universally quantified (<code>!</code> symbol)
and will be converted by gkc to a <i>clause</i> <code>-wolf(X) | animal(X).</code>.

<p>The second statement is existentially quantified (<code>?</code> symbol) and will 
be converted by gkc to a clause <code>wolf($sk7).</code>
where <code>$sk7</code> is a new constant invented by gkc which should not occur 
in any other formula in the problem:
this procedure is called <a href="https://en.wikipedia.org/wiki/Skolem_normal_form">Skolemization</a>.
Gkc always uses the <code>$sk</code> prefix for such constants and functions, using a new number <i>N</i>
for each new one. The original formula is assumed not to contain <code>$skN</code> form symbols.</p>

<p>The last statement expresses the question to be proved: is 
there an animal that likes to eat a grain eating animal?
It has a conjecture role and has to be first negated and then converted to 
a clause:</p>

<pre><code>-eats(X,Y) | -eats(Z,X) | -grain(Y) | -animal(X) | -animal(Z).
</code></pre>

<p>In general, one formula in the input may create several clauses and the optimized
algorithm for creating such clauses is nontrivial, sometimes involving mini-scoping and the creation of new
definitions (new predicates) to make the size and number of generated clauses smaller.</p>

</div>
<pre><code id="example_14_input_code">
fof(pel47_1_1,axiom,
  ( ! [X] :
      ( wolf(X)
      => animal(X) ) )).

fof(pel47_1_2,axiom,
  ( ? [X1] : wolf(X1) )).

fof(pel47_2_1,axiom,
  ( ! [X] :
      ( fox(X)
      => animal(X) ) )).

fof(pel47_2_2,axiom,
  ( ? [X1] : fox(X1) )).

fof(pel47_3_1,axiom,
  ( ! [X] :
      ( bird(X)
      => animal(X) ) )).

fof(pel47_3_2,axiom,
  ( ? [X1] : bird(X1) )).

fof(pel47_4_1,axiom,
  ( ! [X] :
      ( caterpillar(X)
      => animal(X) ) )).

fof(pel47_4_2,axiom,
  ( ? [X1] : caterpillar(X1) )).

fof(pel47_5_1,axiom,
  ( ! [X] :
      ( snail(X)
      => animal(X) ) )).

fof(pel47_5_2,axiom,
  ( ? [X1] : snail(X1) )).

fof(pel47_6_1,axiom,
  ( ? [X] : grain(X) )).

fof(pel47_6_2,axiom,
  ( ! [X1] :
      ( grain(X1)
      => plant(X1) ) )).

fof(pel47_7,axiom,
  ( ! [X] :
      ( animal(X)
      => ( ! [Y] :
            ( plant(Y)
            => eats(X,Y) )
        | ! [Y1] :
            ( ( animal(Y1)
              & much_smaller(Y1,X)
              & ? [Z] :
                  ( plant(Z)
                  & eats(Y1,Z) ) )
            => eats(X,Y1) ) ) ) )).

fof(pel47_8,axiom,
  ( ! [X,Y] :
      ( ( bird(Y)
        & ( snail(X)
          | caterpillar(X) ) )
      => much_smaller(X,Y) ) )).

fof(pel47_9,axiom,
  ( ! [X,Y] :
      ( ( bird(X)
        & fox(Y) )
      => much_smaller(X,Y) ) )).

fof(pel47_10,axiom,
  ( ! [X,Y] :
      ( ( fox(X)
        & wolf(Y) )
      => much_smaller(X,Y) ) )).

fof(pel47_11,axiom,
  ( ! [X,Y] :
      ( ( wolf(X)
        & ( fox(Y)
          | grain(Y) ) )
      => ~ eats(X,Y) ) )).

fof(pel47_12,axiom,
  ( ! [X,Y] :
      ( ( bird(X)
        & caterpillar(Y) )
      => eats(X,Y) ) )).

fof(pel47_13,axiom,
  ( ! [X,Y] :
      ( ( bird(X)
        & snail(Y) )
      => ~ eats(X,Y) ) )).

fof(pel47_14,axiom,
  ( ! [X] :
      ( ( caterpillar(X)
        | snail(X) )
      => ? [Y] :
          ( plant(Y)
          & eats(X,Y) ) ) )).

fof(pel47,conjecture,
  ( ? [X,Y] :
      ( animal(X)
      & animal(Y)
      & ? [Z] :
          ( grain(Z)
          & eats(Y,Z)
          & eats(X,Y) ) ) )).
</code></pre>
  

<div id="example_14_proof_notes">

<p>The simple format proof contains only clauses created from the formulas: the original names of
formulas used are indicated like</p>

<pre><code>[in,pel47_1_2, axiom] wolf($sk7).
</code></pre>

<p>
The simple output format used in all the previous examples does not directly contain
the original input formulas of the fof language of TPTP and the steps in conversion, 
only the names of the formulas. TPTP suggests using a particular
format of output, including the original input before clausification,
proved-successfully-marker, and the begin and end markers of proof.</p>

<p>To use the TPTP suggested output format, select <i>TPTP format</i> from the
box after <b>Convert to</b> button and press <b>Prove</b> again. 

<p>
Try out the <i>json</i> format as well: the details of the json syntax for
formulas are given in the <a href="https://github.com/tammet/json-ld-logic">JSON-LD-LOGIC</a>
specification proposal and examples can be tried out in the <a href="../json.html">json
playground</a>.
<p>
You can also convert the input example to different equivalent input
formats by selecting the format from the box and clicking 
the <b>Convert to</b> button. In particular, check out the difference
between <i>TPTP clauses</i> and the <i>simple clauses</i>: the former
wraps all clauses with the special
<code>cnf(statement_name, statement_role, statement)</code> form, otherwise
these two are equivalent.
</div>



<div id="example_15_input_notes"><h3>Steam using simple formulas</h3>

<p>
Gkc allows the TPTP formula syntax to be used without the <code>fof(nam,role,formula)</code>
wrapping. The current example is exactly the same as the previous example,
but this time without wrapping, except for the last formula: it is useful to indicate
the <i>role</i> of the question, which can be only done using the wrapped syntax.
<p>
Gkc does not know which clause is a question: this is ok,
but it is bad for efficiency in case of large clause sets.</p>
<p>
  There is a simple way to tell gkc that some clause or a formula is indeed a question
and gkc should heavily focus on that clause or a formula.</p>
<p>Instead of writing your negated question like</p>

<pre><code>-father(john,pete).
</code></pre>

<p>write it with this wrapping  as a fof formula (observe double parentheses at the end)</p>

<pre><code>fof(q1,negated_conjecture,
    -father(john,pete)).
</code></pre>

<p>or a cnf formula (i.e. simple clause) in TPTP language</p>

<pre><code>cnf(q1,negated_conjecture,
    -father(john,pete)).
</code></pre>

<p>and then gkc knows that this clause should get priority in search.</p>

<p>Similarly, you can tell gkc that a clause or a formula is not just
an arbitrary axiom which may or may not be used, but an important
assumption likely to be used in the proof:</p>

<pre><code>cnf(a1,assumption,
    person(john)).
</code></pre>

</div>
<pre><code id="example_15_input_code">
! [X] : ( wolf(X) => animal(X) ).

? [X1] : wolf(X1).

! [X] :  ( fox(X) => animal(X) ).

? [X1] : fox(X1).

! [X] :  ( bird(X) => animal(X) ).

? [X1] : bird(X1).

! [X] :  ( caterpillar(X) => animal(X) ).

? [X1] : caterpillar(X1).

! [X] : ( snail(X) => animal(X) ).

? [X1] : snail(X1).

? [X] : grain(X).

! [X1] : ( grain(X1) => plant(X1) ).

! [X] :
    ( animal(X)
    => ( ! [Y] :
          ( plant(Y)
          => eats(X,Y) )
      | ! [Y1] :
          ( ( animal(Y1)
            & much_smaller(Y1,X)
            & ? [Z] :
                ( plant(Z)
                & eats(Y1,Z) ) )
          => eats(X,Y1) ) ) ).

! [X,Y] :
    ( ( bird(Y)
      & ( snail(X)
        | caterpillar(X) ) )
    => much_smaller(X,Y) ).

! [X,Y] :
    ( ( bird(X)
      & fox(Y) )
    => much_smaller(X,Y) ).

! [X,Y] :
    ( ( fox(X)
      & wolf(Y) )
    => much_smaller(X,Y) ).

! [X,Y] :
    ( ( wolf(X)
      & ( fox(Y)
        | grain(Y) ) )
    => ~ eats(X,Y) ).

! [X,Y] :
    ( ( bird(X)
      & caterpillar(Y) )
    => eats(X,Y) ).

! [X,Y] :
    ( ( bird(X)
      & snail(Y) )
    => ~ eats(X,Y) ).

! [X] :
    ( ( caterpillar(X)
      | snail(X) )
    => ? [Y] :
        ( plant(Y)
        & eats(X,Y) ) ).

fof(pel47,conjecture,
    ( ? [X,Y] :
        ( animal(X)
        & animal(Y)
        & ? [Z] :
            ( grain(Z)
            & eats(Y,Z)
            & eats(X,Y) ) ) )).         
</code></pre>


<div id="example_15_proof_notes"></div>

<div id="example_16_input_notes"><h3>Example 16 for the strategy</h3>
By default gkc automatically selects a number of strategies to run one-by one
and outputs either message that the proof was found along with the proof or a message
that no proof was found.</p>

<p>You can tell gkc the exact strategy by entering
the json format strategy text like this into the 
<i>Strategy as json text</i> box:</p>

<pre><code>{
"print_level": 15,
"max_seconds": 1,
"strategy":["hardness_pref"],
"query_preference":1  
}
</code></pre>  

<p>There are two somewhat different ways to write the strategy file:
either indicate a single strategy (single run) like in the example above
or multiple runs like this:</p>

<pre><code>{
"print_level": 15,
"runs":[
{"max_seconds": 1,"strategy":["unit"],"query_preference":0},
{"max_seconds": 1,"strategy":["unit"],"query_preference":1},
{"max_seconds": 1,"strategy":["negative_pref"],"query_preference":0},
{"max_seconds": 1,"strategy":["negative_pref"],"query_preference":1},
{"max_seconds": 1,"strategy":["negative_pref"],"query_preference":0,"weight_select_ratio":100, "depth_penalty":100, "length_penalty":100},
{"max_seconds": 1,"strategy":["hardness_pref","posunitpara"],"query_preference":0,"weight_select_ratio":20,"depth_penalty": 50, "length_penalty":100},

{"max_seconds": 5,"strategy":["unit"],"query_preference":0},
{"max_seconds": 5,"strategy":["unit"],"query_preference":1},
{"max_seconds": 5,"strategy":["negative_pref"],"query_preference":0}
]
}
</code></pre>

<p>In the latter case gkc will try out all these strategies in that order</p>

<p>A simple way to obtain such run sequences is to use the <i>Print level</i> select box
value <i>+ Statistics</i> which will then automatically construct and print out a suitable full strategy json
with many runs, which you can simply copy and paste into your own file for later modification.</p>

<p>The default value for limit-type fields starting with max_ is 0, indicating that no limit is set.</p>

<p>In case "equality": N is not set to 0, GKC uses reflexivity, paramodulation and demodulation 
with knuth-bendix ordering for handling equality.</p>

<p>The list "strategy": [...] contains the main search strategy indicators, default off:</p>

<ul>
<li>"query_focus" : use a goal-oriented set-of-support strategy with binary resolution</li>
<li>"negative_pref" : use binary resolution with negative literals preferred</li>
<li>"positive_pref" : use binary resolution with positive literals preferred</li>
<li>"hardness_pref" : use binary resolution with "hardest" (similar to weight) literals preferred</li>
<li>"knuthbendix_pref" : use binary resolution with knuth-bendix ordering of literals</li>
<li>"hyper" : use hyperresolution, with negative literals preferred</li>
<li>"posunitpara": perform paramodulation from units only</li>
<li>"prohibit_nested_para": disallow paramodulation if either parent is derived by paramodulation</li>
<li>"max_ground_weight": use the weight of the heaviest literal as the base weight of a clause</li>
<li>"unit", "double" or "triple" : use binary unit resolution or its generalization: (one of the arguments must be unit, a two-literal or three-literal clause, <br />
respectively. These may be added to the list in addition to the previous strategy indicators, for example, like ["query_focus","unit"].</li>
</ul>

<p>Other useful parameters, to be used outside the "strategy": [...] list:</p>

<ul>
<li>"print": 0 or 1, where 0 prohibits almost all printing, default 1.</li>
<li>"print_level": integer determining the level of output: useful values are between 0 and 50, default 10, for -tptp 1 gkc uses 15.</li>
<li>"print_json": 0 or 1, where 0 is default and 1 forces json output.</li>
<li>"print_tptp": 0 or 1, where 0 is default and 1 forces tptp-style proof output</li>
<li>"max_size", "max_length", "max_depth", "max_weight" indicate limits on kept clauses, defaults are 0.</li>
<li>"equality" : 1 or 0, with 1 being default and 0 prohibiting equality handling.</li>
<li>"rewrite" : 1 or 0, with 1 being default and 0 prohibiting using equations for rewriting.</li>
<li>"max_dseconds": N being an integer limit of tenths of seconds for one run, default 0 (no limit).</li>
<li>"max_seconds": N being an integer limit of seconds for one run, default 0 (no limit). This is an alternative
  to the "max_dseconds" key.
</li>
<li>"weight_select_ratio": N indicating the ratio of picking by order derived / clause weight, default is 5.</li>
<li>"max_answers": N indicating the maximal number of proofs searched for until search stops, default is 1.</li>
<li>"reverse_clauselist": N either default 0 or 1, where 1 follows the actual order for input clauses, starting from the end.</li>
<li>"sine": input filter with N either 1 or 2 where 1 is a less restrictive (accepts more clauses) and 2 more restrictive. NB! Sine is automatically switched off if the -provekb switch is used.</li>
<li>"depth_penalty": additional penalty for clause depth, default 1</li>
<li>"length_penalty": additional penalty for clause length, default 1</li>
<li>"var_weight": weight of a variable, default 5</li>
<li>"var_weight": weight of a repeated variable, default 7</li>
<li>"query_preference": N being 0, 1, 2 or 3 indicates which parts of the problem are treated as goals, assumptions or axioms:
  0 stands for no goal/assumption preference.
  1 stands for input preference (the assumption and conjecture formulas of fof)
  2 stands for making non-included formulas assumptions
  3 stands for considering only the negative clauses from conjecture to be goals</li>
</ul>

<p>For "max_seconds"&lt;2 gkc will automatically use immediate check for contradiction when a clause is derived. </p>

For the current example gkc tries out 16 search strategies before it hits a suitable one:
you can give it the following search strategy to find the proof very quickly:
<pre><code>{
"print_level": 15,
"runs":[
{"max_seconds":1,"strategy":["hardness_pref"],"query_preference":1}
]
}
</code></pre>

</div>
<pre>
<code id="example_16_input_code">
% File     : SWV237+1 : TPTP v7.3.0. Released v3.2.0.
% Domain   : Software Verification (Security)
% Problem  : Visa Security Module (VSM) attack
% Version  : Especial.
% English  : This models the API of the Visa Security Module (VSM). The
%            conjecture allows the discovery of Bond's attack.

% Refs     : [BA01]  Bond & Anderson (2001), API-Level Attacks on Embedded
%          : [Ste06] Steel (2006), Email to G. Sutcliffe

fof(enc_dec_cancel,axiom,(
  ! [U,V] : enc(i(U),enc(U,V)) = V )).

fof(dec_enc_cancel,axiom,(
    ! [U,V] : enc(U,enc(i(U),V)) = V )).

fof(double_inverse_cancel,axiom,(
    ! [U] : i(i(U)) = U )).

fof(keys_are_symmetric,axiom,(
    ! [U] :
      ( p(U)
     => p(i(U)) ) )).

fof(key_translate_from_ZCMK_to_TMK,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
     => p(enc(tmk,enc(i(enc(i(zcmk),V)),U))) ) )).

fof(key_translate_from_TMK_to_ZCMK,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
     => p(enc(i(enc(i(zcmk),V)),enc(i(tmk),U))) ) )).

fof(receive_working_key_from_switch,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
     => p(enc(wk,enc(i(tmk),U))) ) )).

fof(encrypt_a_PIN_derivation_key_under_a_TMK,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
     => p(enc(enc(i(tmk),V),enc(i(tmk),U))) ) )).
     fof(encrypt_a_stored_comms_key,axiom,(
      ! [U,V,W] :
        ( ( p(U)
          & p(V)
          & p(W) )
       => p(enc(enc(i(tmk),V),enc(i(tc),U))) ) )).
  
%----This command now removed from normal VSM operation to fix attack
fof(encrypt_clear_key_as_Tcomms_key,axiom,(
  ! [U,V,W] :
    ( ( p(U)
      & p(V)
      & p(W) )
    => p(enc(tc,U)) ) )).

fof(data_encrypt,axiom,(
  ! [U,V,W] :
    ( ( p(U)
      & p(V)
      & p(W) )
    => p(enc(enc(i(tc),U),V)) ) )).

fof(data_decrypt,axiom,(
  ! [U,V,W] :
    ( ( p(U)
      & p(V)
      & p(W) )
    => p(enc(i(enc(i(tc),U)),V)) ) )).

fof(data_translate_PIN_from_local_to_interchange_key,axiom,(
  ! [U,V,W] :
    ( ( p(U)
      & p(V)
      & p(W) )
    => p(enc(enc(i(wk),W),enc(i(enc(i(tmk),V)),U))) ) )).
    fof(data_translate_between_interchange_keys,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
      => p(enc(enc(i(wk),W),enc(i(enc(i(wk),V)),U))) ) )).

%----Bond unsure if this command actually implemented in VSM
fof(data_translate_PIN_from_local_storage_to_interchange_key,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
      => p(enc(enc(i(wk),V),enc(i(lp),U))) ) )).

fof(attacker_can_encrypt,axiom,(
    ! [U,V,W] :
      ( ( p(U)
        & p(V)
        & p(W) )
      => p(enc(U,V)) ) )).
%----Initial knowledge of intruder
fof(intruder_knows_1,axiom,(
    p(enc(tmk,pp)) )).

fof(intruder_knows_2,axiom,(
    p(enc(wk,w)) )).

fof(intruder_knows_3,axiom,(
    p(enc(w,t1)) )).

fof(intruder_knows_4,axiom,(
    p(enc(lp,t2)) )).

fof(intruder_knows_5,axiom,(
    p(enc(tc,k)) )).

fof(intruder_knows_6,axiom,(
    p(kk) )).

fof(intruder_knows_7,axiom,(
    p(i(kk)) )).

fof(intruder_knows_8,axiom,(
    p(a) )).

%----Goal for the attacker is to make a PIN (enc(pp,a))
fof(co1,conjecture,(
    p(enc(pp,a)) )).
    
</code>
</pre>
<div id="example_16_proof_notes"></div>

<div id="example_17_input_notes"><h3>Example 17 for arithmetic</h3>

<p>Gkc supports integers and floating point numbers along with
basic arithmetic operators, but does not provide
any axioms or built-in knowledge for the properties of arithmetic operators,
except simple evaluation.
</p>

Citing TPTP: the extent to which ATP systems are able to work with the arithmetic predicates and
functions can vary, from a simple ability to evaluate ground terms, e.g., 
<code>$sum(2,3)</code> can be evaluated to <code>5</code>, through an ability to instantiate variables 
in equations involving such functions, e.g., <code>$product(2,$uminus(X)) = $uminus($sum(X,2))</code>
can instantiate <code>X</code> to <code>2</code>, to extensive algebraic manipulation capability. 

<p>As a trivial practical example gkc is unable to find that</p>

<pre><code>-p(5).
p(2+X).
</code></pre>

<p>is contradictory. This would require either solving the equation 5=2+X or
generating an ever-growing set of numberic instances of clauses, none
of which gkc currently attempts.</p>
<p>However, for the last example one can construct a number-generating
clause set - which essentially enforces the creation of numeric 
instances - like this:</p>  
<pre><code>-p(5).
n(0).
-n(X) | n(1+X).
-n(X) | p(2+X).
</code></pre>
<p>leading to a proof.</p>

The same general principle holds for lists and distinct symbols interpreted as strings.
<p>
This said, the numbers and arithmetic functions and predicates are defined following the 
<a href="http://www.tptp.org/TPTP/TR/TPTPTR.shtml#Arithmetic">TPTP arithmetic system</a>
plus a few convenience operators for writing infix terms:
<ul>
<li>Type detection predicates $is_int, $is_real.
<li>Comparison predicates $less, $lesseq, $greater, $greatereq.
<li>Type conversion functions $to_int, $to_real.
<li>Arithmetic functions on integers and reals:
$sum", "$difference", "$product", 
"$quotient", "$quotient_e",
"$remainder_e", "$remainder_t", "$remainder_f", 
"$floor", "$ceiling",
"$uminus", "$truncate", "$round.
 <p>
 Note: these comparison predicates and arithmetic functions take exactly two arguments.
<p>
 Example: <code>$less($sum(1,$to_int(2.1)),$product(3,3))</code>.

<li>Additional convenience predicate is used: $is_number is true
if and only if $is_int or $is_real is true.

<li>Additional infix convenience functions +, -, *, / are
used with the same meaning as $sum, $difference, $product and 
$quotient, respectively.
<p>
Example: <code>$less(1+(1+2),(3*3))</code>
<p>
Note: these convenience functions take also exactly two arguments.
</ul>
<p><b>NB!</b> Do not use a variable or a non-numeric constant as a first element of the 
infix arithmetic expression like <code>p(X*2)</code>, otherwise 
the whole expression will be parsed as a single variable <i>X*2</i>. No such restrictions
apply for the prefix form.
</div>
<pre><code id="example_17_input_code">p(2).
-p(X) | p(2*X).
-p(X) | $less(X,128).
</code>
</pre>
<div id="example_17_proof_notes">
</div>



<div id="example_18_input_notes"><h3>Example 18 for lists for</h3>
intro 18 
</div>
<pre>
<code id="example_18_input_code">code 18
</code>
</pre>
<div id="example_18_proof_notes">
note 18
</div>


<div id="example_19_input_notes"><h3>Example 19 for distinct symbols</h3>
  intro 19 
  </div>
  <pre>
  <code id="example_19_input_code">code 19
  </code>
  </pre>
  <div id="example_19_proof_notes">
  note 19
  </div>  

<p>However, for the last example one can construct a number-generating
clause set - which essentially forces the creation of numeric 
instances - like this:</p>

<pre><code>-p(5).
n(0).
-n(X) | n(1+X).
-n(X) | p(2+X).
</code></pre>

<p>leading to a proof</p>

<pre><code>1: [in, axiom] n(+(1,X)) | -n(X).
2: [in, axiom] n(0).
3: [mp, 1.1, 2, fromaxiom] n(1).
4: [mp, 3, 1.1, fromaxiom] n(2).
5: [mp, 4, 1.1, fromaxiom] n(3).
6: [in, axiom] p(+(2,X)) | -n(X).
7: [in, axiom] -p(5).
8: [mp, 5, 6.1, 7, fromaxiom] false
</code></pre>

<h3>Large theory batch files</h3>

<p>Gkc is capable of time-efficiently handling a special format of 
packaging a large number of proof tasks into a single batch run file.
These pages contain a description of the format and specific requirements: </p>

<ul>
<li><a href="http://www.tptp.org/CASC/J10/Design.html#Problems">CASC J10 design: Problems</a></li>
<li><a href="http://www.tptp.org/CASC/J10/Design.html#SystemProperties">CASC J10 design: System properties</a></li>
</ul>

<p>In order to try out a simple example, there is <a href="largebatch.txt">largebatch.txt</a> file:</p>

<pre><code>mkdir out
./gkc largebatch.txt out
</code></pre>

<p>Here gkc determines automatically that the largebatch.txt
has a specific format and should be handled as a batch of
problems, with output files put into the out folder.</p>

<p>This capability is only available under UNIX.</p>

</div>

<!-- at-end-scripts -->

<script>
// instead of jquery
function gid(x) { return document.getElementById(x); }
// reading a file
function handleFileSelect(evt) {
  var files = evt.target.files; 
  for (var i = 0, f; f = files[i]; i++) {
    var reader = new FileReader();
    reader.onload = (function(theFile) {
      return function(e) { gid('gkc_1_input').value=e.target.result; };
    })(f);
    reader.readAsText(f);
  }
}
// do this to initialize file reading:
gid('files').addEventListener('change', handleFileSelect, false);

</script>
<!-- ui with bootstrap -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<!-- Solver code -->
<script async src="gkcjs.js"></script>
<!--
<script>
// google analytics
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61132529-1', 'auto');
  ga('send', 'pageview');
</script> 
-->
</body>
</html>
