<!DOCTYPE html>
<html lang="en">
<head itemscope>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="description" content="Online logic solvers.">
<meta name="author" content="Tanel Tammet">
<meta name="keywords" content="logic, solvers, reasoning, propositions, dpll, resolution, truth table"> 

<meta itemprop="itemtype" content="http://schema.org/SoftwareApplication">
<meta itemprop="name" content="Logictools">
<meta itemprop="description" content="Logic solvers and conversion tools.">
<meta itemprop="url" content="http://logictools.org">
<meta itemprop="operatingSystems" content="Linux, Windows">
<meta itemprop="softwareApplicationCategory" content="WebApplication">

<meta property="og:title" content="Logictools"> 
<meta property="og:url" content="http://logictools.org"> 
<meta property="og:site_name" content="Logictools"> 
<meta property="og:type" content="website">
<meta property="og:description" content="Logic solvers and conversion tools.">
<meta property="fb:admins" content="tanel.tammet">

<link rel="shortcut icon" href="logo.png">

<title>Logictools</title>
<!-- Bootstrap core CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
<!-- Custom styles for this template -->
<link href="wdb.css" rel="stylesheet">
<style>
.result {
  padding: 15px; 
  white-space: pre-wrap;
}
.result_wiblock {
  padding: 0px; 
}   
.syntax {  
  width: 70px; height: 30px; text-align: center; 
  padding: 0px 0px 1px 0px;  font-size: 12px;
  line-height: 1.42; border-radius: 15px; 
  background-color: #cccccc; color: #337ab7; margin-left: 15px;
}         

.btn-file {
  position: relative;
  overflow: hidden;
}
.btn-file input[type=file] {
  position: absolute;
  top: 0;
  right: 0;
  min-width: 100px;
  min-height: 100px;
  font-size: 100%;
  text-align: right;
  filter: alpha(opacity=0);
  opacity: 0;
  outline: none;
  background: white;
  cursor: inherit;
  display: block;
}

</style>
<script>
'use strict';

var gkcoutput="";

function useGkc(el) {
  var placeid;
  var input, output;
  var inputarea, outputplace;
  var arglist;
  var sel, conversion;
 
  var placeid=el.parentNode.id;
  var div = document.getElementById(placeid+"_output"); 
  //clearOutputByPlace(placeid); 
  inputarea=document.getElementById("gkc_1_input");
  outputplace=document.getElementById("result");  
  input=inputarea.value;  
  arglist=["-text",input];
  
  sel=document.getElementById("conversion_select");
  conversion=sel.options[sel.selectedIndex].value;
  if (conversion=="json" || conversion=="tptp") {
    arglist=["-text",input,"-"+conversion];
  } else if (conversion=="simple" || conversion=="clauses") {
    arglist=["-text",input];  
  } else {
    conversion=conversion.substring(8);        
    arglist=["-text",input,"-"+conversion];
  }
  //console.log(arglist);
  gkcoutput="";
  gkc(arglist);
  //console.log("gkcoutput",gkcoutput);
  document.getElementById("result").innerHTML=gkcoutput;
}  

function gkc(arglist) {
  Module.callMain(arglist);
}  

function convert(el) {
  var placeid;
  var input, output;
  var inputarea, outputplace;
  var arglist;
  var conversion;
  var sel;

  var placeid=el.parentNode.id;
  var div = document.getElementById(placeid+"_output"); 
  //clearOutputByPlace(placeid); 
  inputarea=document.getElementById("gkc_1_input");
  outputplace=document.getElementById("result");  
  input=inputarea.value;  

  sel=document.getElementById("conversion_select");
  conversion=sel.options[sel.selectedIndex].value;
  if (conversion=="json" || conversion=="tptp") {
    arglist=["-text",input,"-convert","-"+conversion];
  } else if (conversion=="simple" || conversion=="clauses") {
    arglist=["-text",input,"-clausify"];  
  } else {
    conversion=conversion.substring(8);        
    arglist=["-text",input,"-clausify","-"+conversion];
  }  
  gkcoutput="";
  //console.log(arglist);
  gkc(arglist);
  //console.log("gkcoutput",gkcoutput);
  document.getElementById("result").innerHTML=gkcoutput;
}

function clearOutputByPlace(placeid) { 
  var div = document.getElementById(placeid+"_output");
  while(div.firstChild){
    div.removeChild(div.firstChild);
  }
}

function clearOutput(el) { 
  document.getElementById("result").innerHTML="";
  document.getElementById("proof_notes").innerHTML="";    
}

function clearInputByPlace(placeid) { 
  document.getElementById(placeid+"_input").value="";  
}

function clearInput(el) { 
  document.getElementById("gkc_1_input").value=""; 
  document.getElementById("input_notes").innerHTML="";  
}

function fillOutput(placeid,text) { 
  document.getElementById(placeid+"_output").innerHTML=text;  
}

// example selection

function selectExample() {
  var sel;
  var value;
  var data;
  var notes;
  var placeid,html,el;

  sel=document.getElementById("select_example");
  value=sel.options[sel.selectedIndex].value;

  if (value=="examples") {
    document.getElementById("input_notes").innerHTML="";
    document.getElementById("proof_notes").innerHTML="";
    document.getElementById("result").innerHTML="";
    return;
  }
 
  placeid="example_"+value+"_";

  el=document.getElementById(placeid+"input_code");
  if (el) {
    html=el.innerHTML; 
    if (html) {
      html=html.replace(new RegExp("&amp;","g"),"&");
      html=html.replace(new RegExp("&gt;","g"),">");
      document.getElementById("gkc_1_input").value=html;
    }
  }
  if (!el || !html) document.getElementById("gkc_1_input").value="";

  el=document.getElementById(placeid+"input_notes");
  if (el) {
    html=el.innerHTML;
    if (html) {      
      document.getElementById("input_notes").innerHTML=html;
    }
  } 
  if (!el || !html) document.getElementById("input_notes").innerHTML=""; 

  el=document.getElementById(placeid+"proof_notes");
  if (el) {
    html=el.innerHTML;
    if (html) {
      document.getElementById("proof_notes").innerHTML=html;
    }
  }
  if (!el || !html) document.getElementById("proof_notes").innerHTML="";  

  html="<div class='click_prove'>Click the Prove button!</div>";
  html="<button onclick='useGkc(this); return false;' ";
  html+="class='btn btn-small btn-primary'style='width: 70px;''>Prove</button>";
  document.getElementById("result").innerHTML=html;
}

// simplified Module glue code originally produced by emscripten

var Module={  
  noInitialRun: true,
  preRun:[],
  postRun:[],
  print: function(s) {
    gkcoutput+=s+"\n";    
  },
  printErr:function(e){
    arguments.length>1 && (e=Array.prototype.slice.call(arguments).join(" "));
    if ((JSON.stringify(e)).includes("abort(OOM)")) {
      location.reload();
    }
    console.error(e);    
  },
  setStatus:function(e){ return 1 },
  totalDependencies:0,
  monitorRunDependencies:function(e){
    this.totalDependencies=0; 
    Module.setStatus(e ? "Preparing... ("+(this.totalDependencies-e)+"/"+this.totalDependencies+")"
       : "All downloads complete.")
  }
};
/*
window.onerror=function(e){
  console.error(e);
  
  // Module.setStatus("Exception thrown, see JavaScript console"),
  // Module.setStatus=function(e){
  //   e && Module.printErr("[post-exception status] "+e)
  // }
  
}
*/
</script>
</head>

<body>

<div id="fb-root"></div>

<div class="navbar navbar-inverse navbar-static-top" style="background-color: #333333;">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Logictools</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="active"><a href="index.html">Solve</a></li>        
        <li class="dummy"><a href="propositional.html">Propositional logic</a></li>
        <li class="dummy"><a href="predicate.html">Predicate logic</a></li>
        <li class="dummy"><a href="download.html">Download</a></li>        
        <li class="dummy"><a href="about.html">About</a></li> 
      </ul>
    </div><!--/.navbar-collapse -->
  </div>
</div>

<!-- content after titlebar -->


<div class="container">
  <div class="row">
    <div class="col-md-12 wblock wblock1">
    
    <!--------------------------- --->

<h2>Solve a predicate logic reasoning task: 
  <button type="button" class="btn btn-default" 
         onclick="gid('syntax').style.display='block'; document.location='#syntax'; "
         style="
          width: 70px; height: 30px; text-align: center; 
          padding: 0px 0px 1px 0px;  font-size: 12px;
          line-height: 1.42; border-radius: 15px; 
          background-color: #cccccc; color: #337ab7; margin-left: 15px;"
         >syntax</button>
</h2>                

  <form class="form-inline" method="post">
    <div class="wblock">      
      <div id="gkc_1">     
        <textarea class="form-control" id="gkc_1_input" 
        style="height: 200px; width:100%; margin-bottom: 20px;">
brother(john,james).
-brother(X,Y) | brother(Y,X).
-brother(james,john). 
        </textarea>
        <button onclick="useGkc(this); return false;" class="btn btn-small btn-primary"
        style="width: 70px;">Prove</button>
        <select class="form-control" style="width: 110px;" id="select_example"
          onchange="selectExample()">
          <option value="examples">examples</option>
          <option value="1">basics</option>
          <option value="2">answers</option>
          <option value="3">rules</option>
          <option value="4">or-answers</option>
          <option value="5">more rules</option>
          <option value="6">functions</option>
          <option value="7">gf with fun</option>
          <option value="8">equalities</option>
          <option value="9">reflexivity</option>
          <option value="10">multi-answers</option>
          <option value="11">algebra</option>
          <option value="12">unprovable</option>
          <option value="13">hard</option>
          <option value="arithmetic1">arithmetic 1</option>
          <option value="arithmetic2">arithmetic 2</option>
          <option value="arithmetic3">arithmetic 3</option>
          <option value="arithmetic4">arithmetic 4</option>          
        </select>
        &nbsp;or&nbsp;
        <span class="btn btn-default btn-file">
        Browse<input type="file" id="files" name="files"  
         value="">
        </span>    
        &nbsp;&nbsp;&nbsp;  
        <button onclick="convert(this); return false;" class="btn btn-small btn-primary"
        >Convert to</button>
        <select class="form-control" style="width: 110px;" id="conversion_select">
          <option value="simple">simple</option>
          <option value="json">json</option>
          <option value="tptp">tptp</option>
          <option value="clauses">simple clauses</option>
          <option value="clauses_json">json clauses</option>
          <option value="clauses_tptp">tptp clauses</option>          
        </select>
        &nbsp;&nbsp;&nbsp;
        <button onclick="clearOutput(this); return false;" class="btn btn-small btn-default"
        >Strategy</button>           
        &nbsp;&nbsp;&nbsp;            
        <button onclick="clearOutput(this); return false;" class="btn btn-small btn-default"
        >Clear result</button>
        <button onclick="clearInput(this); return false;" class="btn btn-small btn-default"
        >Clear input</button>
        <a href="#solveModal" data-toggle="modal" class="qlink">
          <button type="button" class="btn btn-default" style=" 
           width: 30px; height: 30px; text-align: center; padding: 6px 0;  font-size: 12px;
           line-height: 1.42; border-radius: 15px; 
           background-color: #cccccc; color: #337ab7; margin-left: 15px;">?</button>
        </a> 
                         
      </div>      
    </div>
    <p>                  
  </form>

<p>
<div id="input_notes"></div>
<p>
<h2>Result:</h2>

<div class="container">
  <div class="row">
    <div class="col-md-12 wblock wblock1">
        <div class="wiblock result_wiblock">  
          <div id="result" class="result"></div>
        </div>
    </div>
  </div>
</div>
<p>
  <div id="proof_notes"></div>
<p>

<!-- syntax description is initially hidden -->

<div id="syntax" style="display: none">
<h2>Syntax</h2> 

Use either a conventional formula syntax like
<pre>
(a -&gt; b) &amp; a &amp; -b
</pre>
or a <a href="http://www.domagoj-babic.com/uploads/ResearchProjects/Spear/dimacs-cnf.pdf">dimacs</a> 
version of the clause normal form syntax like
<pre>
-1 2
1
-2
</pre>
which is a conjunction of disjunction lines with numbers standing for variables:
the last example means simply <tt>(-x1 v x2) &amp; x1 &amp; -x2</tt>
<p><p>
For conventional formula syntax:
<ul>
<li>negation symbols are <b>-, ~</b></li>
<li>conjunction symbols are <b>&amp;, and</b></li>
<li>disjunction symbols are <b>|, v, V, or</b></li> 
<li>xor symbols are <b>+, xor </b></li>
<li>implication symbols are <b>-&gt;, =&gt;</b></li> 
<li>equivalence symbols are <b>&lt;-&gt;, &lt;=&gt;</b></li> 
</ul>
There is no operator precedence; all operators are bound from left:<br>
<tt>a &amp; b v c &amp; d v e</tt>  is read as <tt>((((a &amp; b) v c) &amp; d) v e)</tt>
<p><p>
For dimacs you may use or skip the initial comment lines starting with <b>c</b>,
the special <b>p</b> line and the final <b>0</b> symbols at the end of each disjunct.
We allow the trailing <b>0</b>-s only at the end of a line.
<p>
I.e. you may use the full dimacs version like
<pre>
c comment
p cnf 2 3
-1 2 0
1 0
-2 0
</pre>
or just
<pre>
-1 2
1
-2
</pre>


<a href="#" onclick="gid('syntax').style.display='none';">hide syntax</a>
</div>
    
    <!-------------------------- --->
    </div>
  </div>
</div>

<!-- footer -->

<div class="ofooter">  
  <div class="col-md-12 container ifooter">
  </div>  
</div> 


<!-- modal help texts --->


<div class="modal fade" id="solveModal" tabindex="-1" role="dialog" 
    aria-labelledby="solveModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content modal_login">        
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
            <span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="solveModalLabel" style="color: black;">Solve a propositional formula</h4>
      </div>
      <div class="modal-body">                        
        <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">Solving</a> a classical
        <a href="http://en.wikipedia.org/wiki/Propositional_calculus">propositional formula</a>
        means looking for such values of variables that the formula becomes true. For example,
        <tt>(a -&gt; b) &amp; a</tt> becomes true if and only if both <tt>a</tt> and <tt>b</tt> are assigned true. 
        <p><p>
        You can select and try out several solver algorithms: 
        the "<a href='http://en.wikipedia.org/wiki/DPLL_algorithm'>DPLL</a> better" 
        is the best solver amongst the options. 
        <a href="propositional.html">Read from here</a> about the differences between algorithms.
        <p>
        One single suitable set of values
        is enough as a solution: the solver algorithms stop and do not try to find additional solutions. Some of the solver algorithms
        output the suitable values, but some do not, or output a partial set.
        <p>
        It may also happen that the formula is false for all possible values of variables: if so, the solver algorithms report
        that after exhausting the search options. For example,
        <tt>(a -&gt; b) &amp; a &amp; -b</tt> is always false.
        <p>
        Notice that you can check whether some formula <i>F</i> is always true by trying to solve the 
        <b>negated</b> formula <i>-F</i>: in case <i>-F</i> is always false, <i>F</i> must be always true.
        <p>      
        The algorithms may optionally output a trace of the search process. Select "html trace" to see the search
        process: again, read <a href="propositional.html">from here</a> about the search methods used by the
        algorithms.
        <p>
        For formula-syntax input the solvers first convert the formula to a 
        <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form">clause normal form</a>: for certain kinds of formulas this
        conversion step may create a huge output, but in most cases it is a sensible simplification before actual search.
        <p>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->


<div class="modal fade" id="buildModal" tabindex="-1" role="dialog" 
    aria-labelledby="buildModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content modal_login">        
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
            <span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="buildModalLabel">Build</h4>
      </div>
      <div class="modal-body">                        
        The three building options "truth table", "clause normal form" and a "parse tree" are simple,
        useful utilities:
        <p><p>
        <ul>
        <li>
        The <b>truth table</b>
        prints a full  
        <a href="http://en.wikipedia.org/wiki/Truth_table">truth table</a> 
        of a formula up to 1024 rows: nice for checking out
        small propositional formulas.
        <p>
        </li><li>
        The <b>clause normal form</b> is a 
        <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form</a> just as used by
        the solvers. The conversion algorithm used is very simple and does not perform any optimizations. In many
        cases the optimized converters like the 
        <a href="http://en.wikipedia.org/wiki/Tseitin_transformation">Tseitin transformation</a> 
        would give a much smaller output much faster.
        <p>
        </li><li>
        The <b>parse tree</b> prints a formula as a nested list built by the simple
        <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>. 
        This list is later used by the
        clause normal form converter to build the form suitable for solvers. Check the parse tree in case you are
        not sure how the system understands your formula.
        </li>
        </ul>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->


<div class="modal fade" id="generateModal" tabindex="-1" role="dialog" 
    aria-labelledby="generateModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content modal_login">        
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">
            <span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="generateModalLabel" >Generate a problem</h4>
      </div>
      <div class="modal-body">                        
        <b>Generate a problem</b> will generate an example problem in a simple 
        <a href="http://www.domagoj-babic.com/uploads/ResearchProjects/Spear/dimacs-cnf.pdf">DIMACS format</a>
        of a clause normal form, suitable for solvers.
        <p><p>
        The options for the type of a problem are:
        <ul>
          <li><b>random 3-sat</b> generates a random set of 
          <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability">clauses of length 3</a>,
          using the number of
          variables you choose: problems containing more variables are, on the average, harder to solve.
          The number of clauses is always four times the number of variables: this
          is, on the average, a specially hard-to-solve ratio for solvers.
          <p><p>For DPLL try out 200 variables or
          more. Truth table solvers start running into trouble with more than 20 variables. The resolution
          provers are a bit better than the truth table solvers, yet much worse than the DPLL solvers.</li>
          <li><b>all combinations</b> generates a set of clauses representing all possible combinations 
          of the input variables: any such set is unsatisfiable (i.e. no values of variables can make it true).
          The number of clauses is hence always two to the power of the number of variables.</li>
          <li><b>small unsat</b> generates a very small unsatisfiable clause set, consisting of a single long
          clause containing all the variables and N single-element clauses containing all variables negated.</li>
        </ul>
        The <b>clear</b> button simply clears the input field and result.
        <p>
        You can also <b>browse</b> and read the contents of a file into the input area: essentially copy-paste from
        a file.        
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- raw examples text -->

<div hidden>

<h1>Examples for gkc </h1>

<p>We will first give a brief introduction to gkc input and output,
then look at several simple <a href="#Introductory-examples">introductory examples</a>
and continue towards <a href="#Advanced-examples">more advanced use</a>. </p>

<p>On Linux the pre-compiled executable is called gkc, on Windows gkc.exe
and on OS X (macOS) it is gkcosx. Please change the filename on OS X
to gkc or just use gkcosx in the following examples instead of gkc.</p>

<p>Call gkc from the command line from UNIX (i.e. Linux or OS X) like this:</p>

<pre><code>./gkc problemfilename
</code></pre>

<p>and from Windows like this:</p>

<pre><code>gkc problemfilename
</code></pre>

<p>Try it out on a trivial problem in the Examples folder:</p>

<pre><code>./gkc example1.txt
</code></pre>

<p>Unless gkc is already in the Examples folder, you may want to copy it there:</p>

<pre><code>cp gkc Examples/
</code></pre>

<p>You may want to send output to a file in a standard way like this:</p>

<pre><code>./gkc example1.txt &gt; out.txt
</code></pre>

<p>In case you have very little memory on your computer, gkc may
complain about memory and terminate. In this case tell it to use
less memory like this:</p>

<pre><code>./gkc example1.txt -mbsize 500
</code></pre>

<p>which would make it use only half a gigabyte of memory. 
The default for UNIX and Windows 64 is 5 gigabytes, i.e. -mbsize 5000</p>

<p>By default gkc uses four parallel processes on UNIX and a single
process on Windows. On UNIX you can tell it a number of parallel
processes to use like this (0 and 1 mean no parallel processes, any number
larger than 1 means this number of parallel processes):</p>

<pre><code>./gkc example1.txt -parallel 0
</code></pre>

<p>On UNIX you can also force gkc to stop after N seconds by giving a time limit
parameter like this:</p>

<pre><code>./gkc example1.txt -seconds 2
</code></pre>

<h2>Introductory examples</h2>

<p>Topics covered:</p>

<ul>
<li><a href="#Example-1-for-basics">Example 1 for basics</a></li>
<li><a href="#Example-2-for-answers">Example 2 for answers</a></li>
<li><a href="#Example-3-for-rules">Example 3 for rules</a></li>
<li><a href="#Example-4-for-indefinite-answers">Example 4 for indefinite answers</a></li>
<li><a href="#Example-5-for-more-rules">Example 5 for more rules</a></li>
<li><a href="#Example-6-for-equalities-and-functions">Example 6 for equalities and functions</a></li>
<li><a href="#Example-7-for-grandfather-with-functions">Example 7 for grandfather with functions</a></li>
<li><a href="#Example-8-for-equalities-used-in-proof">Example 8 for equalities used in proof</a></li>
<li><a href="#Example-9-for-reflexivity-used-in-proof">Example 9 for reflexivity used in proof</a></li>
<li><a href="#Example-10-for-multiple-answers">Example 10 for multiple answers</a></li>
<li><a href="#Example-algebra">Example algebra</a></li>
<li><a href="#Example-with-an-unprovable-problem">Example with an unprovable problem</a></li>
<li><a href="#Example-with-a-hard-problem">Example with a hard problem</a></li>
<li><a href="#Examples-with-medium-hard-blocks-world-problems">Examples with medium-hard blocks world problems</a></li>
</ul>

<p>These simple examples explain the input, output and basic
functioning of gkc. Run these yourself like</p>

<pre><code>./gkc example1.txt
</code></pre>

<p>The simple logical language used in these examples is inspired
by the <a href="https://www.cs.unm.edu/~mccune/otter/">Otter syntax</a>. 
Gkc can also use other, richer input languages: more about these later.</p>

<div id="example_1_input_notes"><h3>Example 1 for basics</h3>

<p>This is a really trivial example.</p>

<p>We will give two facts: john is a father of pete and
pete is a father of mark. We will ask whether from these
two facts we can derive that john is a father of pete: 
obviously we can.</p>

<p>The facts and the question are written in predicate logic, with the
question posed as a negation, from which gkc derives contradiction.</p>

<p>Why the negation and contradiction? Suppose want to prove a &amp; b =&gt; a.
If we look for contradiction, then we should try to find contradiction from
-(a &amp; b =&gt; a) which is equivalent to  a &amp; b &amp; -a. Essentially, giving
a goal to be proved from axioms (i.e. known facts / rules) as a negated 
statement is a convenient way to organize proof search.</p>

</div>

<p>Input file example1.txt:</p>

<pre><code id="example_1_input_code">father(john,pete).
father(pete,mark).

-father(john,pete).

% what this means:
% let us want to prove a &amp; b =&gt; a
% if we look for contradiction, then we should
% try to find contradiction from
% -(a &amp; b =&gt; a)
% which is equivalent to
% a &amp; b &amp; -a
</code></pre>


<p>Notice that each statement in the input file is terminated with a period sign. 
Minus sign - means negation. I.e. -father(john,pete) means 
<code>john is NOT the father of pete</code>.</p>

<p>Percentage character % is a line comment. Multi-line comments <code>/* .... */</code>
can be used as well. </p>

<p>The order of statements in the file is not really important, although it may cause minor
and essentially unpredictable differences in search behaviour. Essentially, gkc
creates and tries out its own search strategies, like SQL databases. It does not
follow a pre-determined predictable search strategy like PROLOG.</p>

<p>Output from gkc:</p>

<pre><code>result: proof found
for example1.txt
by run 2 fork 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}

proof:
 1: [in, axiom] -father(john,pete).
 2: [in, axiom] father(john,pete).
 3: [simp, 1, 2, fromaxiom] false
</code></pre>

<div id="example_1_proof_notes">

<p>The output first indicates that the proof was found and then tells us
which search attempt with which search strategy found it. Gkc runs a large number
of search attempts with different search strategies both sequentially and in parallel:
run <N> indicates the number of attempt and fork <N> indicates which parallel process
found the proof. </p>

<p>The <code>proof</code> block gives us numbered steps of the proof found:
each step is either a used input fact / rule or a derived fact / rule.</p>

<p>The [in,axiom] means that this fact/rule was given in input.</p>

<p>The [mp, 1, 2, fromaxiom] (not present in this proof) means that this fact / rule 
was derived by modus ponens (i.e. the resolution rule)
from previous steps 1 and 2. More concretely, the first literals of both were cut off and
the rest were glued together. The "fromaxiom" piece of information is informational: 
it indicates the fact / rule was derived from ordinary axioms, not a specially marked goal.</p>

<p>The [simp, 1, 2,fromaxiom] means the same as the [mp,...] above, just a specially simple case.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Resolution_(logic)">Resolution (logic) wiki page</a> 
is a good short intro to the general principles of the derivation rules with the 
<a href="http://lambda.ee/w/images/0/06/Geoffreasoningnotes.pdf">course materials of Geoff Sutcliffe</a> 
being a suitable continuation towards deeper understanding. However, the following examples are understandable without in-depth theoretical background.</p>

<p>Try to modify the file example1.txt by removing the statement <code>-father(john,pete).</code> and
run gkc again. After ca one second gkc will stop and output</p>

<pre><code>result: proof not found.
</code></pre>

<p>Although the task is trivial, gkc does not attempt to be clever and tries out a large number
of search strategies: this is why it takes a second to terminate. You can try running gkc
with the optional switch producing more information to see the whole process:</p>

<pre><code>./gkc example1.txt -tptp 1
</code></pre>

<p>In case gkc does not understand the syntax of the input file it will give a json-formatted
error indicating a culprit line and piece of input like this:</p>

<pre><code>{"error": "syntax error, unexpected URI, expecting '.': file example1.txt place 'as' in line 3:
foo bar ("}
</code></pre>

</div>

<div id="example_2_input_notes"><h3>Example 2 for answers</h3>

<p>Like example 1, but we want to find a concrete person as an answer: we use the special
"$ans" predicate for this. Observe the "answer: $ans(pete). " line in the output
stemming from this answer predicate.</p>

<p>We are using a variable here: any word starting with a capital letter is considered
to be a variable. <code>X</code> is a variable in our example. You could also use, say <code>Something</code>
as a variable: it also starts with a capital letter. All the words starting with
a non-capital letter are constants, functions or predicates.</p>

<p>Vertical bar | is logical or. </p>

<p>Importantly, any rule like a &amp; b =&gt; c should be represented
as -a | -b | c where negated atoms are essentially on the left side of the implication
and the positive atoms on the right side. For example, -a | -b | c | d is equivalent
to (a &amp; b) =&gt; (c | d). You can use =&gt;, &lt;=&gt; and quantifiers directly with the fof syntax
of TPTP: this will be described later.</p>

</div>

<p>Input file example2.txt:</p>

<pre><code id="example_2_input_code">father(john,pete).
father(pete,mark).

-father(john,X) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example2.txt
by run 2 fork 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}

answer: $ans(pete).
proof:
 1: [in, axiom] father(john,pete).
 2: [in, axiom] -father(john,X) | $ans(X).
 3: [mp, 1, 2, fromaxiom] $ans(pete).
</code></pre>

<div id="example_2_proof_notes">
<p>Notice that gkc outputs a line <code>answer: $ans(pete).</code> indicating the substitution
made for <code>X</code>: pete is the answer we were looking for.</p>

<p>Modify the example and try out the line</p>

<pre><code>-father(Y,X) | $ans(Y,X).
</code></pre>

<p>You will get <code>answer: $ans(john,pete).</code> in the output.
It is possible to force gkc to give more answers than just one: more
about that later.</p>
</div>

<div id="example_3_input_notes"><h3>Example 3 for rules</h3>

<p>Now we add a grandfather rule and ask for a grandchild of John.</p>

</div>
<p>Input file example3.txt:</p>

<pre><code id="example_3_input_code">father(john,pete).
father(pete,mark).

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
-father(X,Y) | -father(Y,Z) | grandfather(X,Z).

-grandfather(john,X) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example3.txt
by run 4 fork 3 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":1}

answer: $ans(mark).
proof:
 1: [in, axiom] -father(X,Y) | -father(Z,X) | grandfather(Z,Y).
 2: [in, axiom] father(pete,mark).
 3: [mp, 1, 2, fromaxiom] -father(X,pete) | grandfather(X,mark).
 4: [in, axiom] father(john,pete).
 5: [mp, 3, 4, fromaxiom] grandfather(john,mark).
 6: [in, axiom] -grandfather(john,X) | $ans(X).
 7: [mp, 5, 6, fromaxiom] $ans(mark).
</code></pre>

<div id="example_3_proof_notes">
Notice that the grandfather rule
<pre><code>1: [in, axiom] -father(X,Y) | -father(Z,X) | grandfather(Z,Y).
</code></pre>
is used in two steps in the proof: the first step combines it with the
<code>-grandfather(john,X) | $ans(X)</code>
answer-giving rule and produces a new specialized rule
<pre><code>3: [mp, 1.2, 2, fromaxiom] -father(john,X) | -father(X,Y) | $ans(Y).
</code></pre>
which is then applied to the <code>father(pete,mark)</code> and
<code>father(john,pete)</code> in one big step to give the final <code>$ans(mark).</code>

<p>Generally - depending on the chosen strategy - gkc decides itself whether to combine several rules, apply a rule to one
  argument or several at once. </p>

</div>

<div id="example_4_input_notes"><h3>Example 4 for indefinite answers</h3>

<p>Let us make it unclear which sons pete actually has.</p>

</div>
<p>Input file example4.txt:</p>

<pre><code id="example_4_input_code">father(john,pete).

% either the first or a second or both facts are true:
father(pete,mark) | father(pete,mickey).

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
-father(X,Y) | -father(Y,Z) | grandfather(X,Z).

-grandfather(john,X) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example4.txt
by run 1 fork 0 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":0}

answer: $ans(mark) | $ans(mickey).
proof:
 1: [in, axiom] -father(X,Y) | -father(Z,X) | grandfather(Z,Y).
 2: [in, axiom] -grandfather(john,X) | $ans(X).
 3: [mp, 1.2, 2, fromaxiom] -father(john,X) | -father(X,Y) | $ans(Y).
 4: [in, axiom] father(john,pete).
 5: [mp, 3, 4, fromaxiom] -father(pete,X) | $ans(X).
 6: [in, axiom] father(pete,mickey) | father(pete,mark).
 7: [mp, 5, 6.1, fromaxiom] father(pete,mickey) | $ans(mark).
 8: [in, axiom] father(john,pete).
 9: [mp, 7, 3.1, 8, fromaxiom] $ans(mark) | $ans(mickey).
</code></pre>

<div id="example_4_proof_notes">

<p>Indeed, there is no way to give a definite answer, but gkc gives a correct answer indicating
that either mark or mickey is a grandson of john, or perhaps both are.</p>

<p>The [mp, 1.2, 2, fromaxiom] means that the 2th (numeration 0,1,2,...) literal in the clause at proof step 1 
was cut off with the first (0th) literal of the clause at proof step 2. In case the first literal is cut off,
the N.0 is simplified to N, as in the previous examples.</p>

<p>I.e. literals in a clause are numbered 0, 1, 2, etc and the number 0 is not added to the step number.</p>
</div>

<div id="example_5_input_notes"><h3>Example 5 for more rules</h3>

<p>To make matters a bit more complicated, we add an ancestor rule 
and look for ancestors of mark.</p>

</div>
<p>Input file example5.txt:</p>

<pre><code id="example_5_input_code">father(john,pete).
father(pete,mark).

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
-father(X,Y) | -father(Y,Z) | grandfather(X,Z).

-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).
-father(X,Y) | ancestor(X,Y).

-ancestor(X,mark) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example5.txt
by run 3 fork 2 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":0}


answer: $ans(pete).
proof:
 1: [in, axiom] -father(X,Y) | ancestor(X,Y).
 2: [in, axiom] father(pete,mark).
 3: [mp, 1, 2, fromaxiom] ancestor(pete,mark).
 4: [in, axiom] -ancestor(X,mark) | $ans(X).
 5: [mp, 3, 4, fromaxiom] $ans(pete).
</code></pre>

<div id="example_6_input_notes"><h3>Example 6 for equalities and functions</h3>

<p>Now we reformulate the whole thing with equalities and functions! </p>

<p>father(john)=pete means, as expected, that pete is the father
of john and there can be no other fathers. If you also gave
father(john)=lucas this would make gkc to conclude that
pete and lucas are the same object, i.e. pete=lucas.</p>

<p>Importantly, two different constants are not considered inequal
by default (think of the constants as labels on objects: there could
be several different labels on one object):</p>

<pre><code>a=b.
</code></pre>

<p>does not give a contradiction.</p>

<p>Notice that the following proof does not use equalities, just functions.</p>
</div>
<p>Input file example6.txt:</p>

<pre><code id="example_6_input_code">%father(john,pete).
father(john)=pete.

%father(pete,mark).
father(pete)=mark.

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
%-father(X,Y) | -father(Y,Z) | grandfather(X,Z).
grandfather(father(father(X)),X).

-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).
ancestor(father(X),X).

-ancestor(X,mark) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example6.txt
by run 4 fork 3 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":1}

answer: $ans(father(mark)).
proof:
 1: [in, axiom] ancestor(father(X),X).
 2: [in, axiom] -ancestor(X,mark) | $ans(X).
 3: [mp, 1, 2, fromaxiom] $ans(father(mark)).
</code></pre>
<div id="example_6_proof_notes">
<p>See that gkc was happily answering <code>father(mark)</code> although we have
not said who the father of mark actually is! The functions like <code>father</code> 
do not have to be defined on all the possible objects, they can be partially
known and partially unknown.</p>
</div>

<div id="example_7_input_notes"><h3>Example 7 for grandfather with functions</h3>

<p>Returning to asking about grandfathers, this time using equalities
and functions. Again, notice that the proof does not use equalities, just functions.</p>
</div>
<p>Input file example7.txt:</p>

<pre><code id="example_7_input_code">%father(john,pete).
father(john)=pete.

%father(pete,mark).
father(pete)=mark.

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
%-father(X,Y) | -father(Y,Z) | grandfather(X,Z).
grandfather(father(father(X)),X).

-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).

-grandfather(X,mark) | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example7.txt
by run 3 fork 2 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":0}

answer: $ans(father(father(mark))).
proof:
 1: [in, axiom] grandfather(father(father(X)),X).
 2: [in, axiom] -grandfather(X,mark) | $ans(X).
 3: [mp, 1, 2, fromaxiom] $ans(father(father(mark))).
</code></pre>

<div id="example_7_proof_notes">
<p>Again, father of mark is unknown (undefined) in our example, as well as the
father of the father of mark. </p>
</div>

<div id="example_8_input_notes"><h3>Example 8 for equalities used in proof</h3>

<p>Next we ask very concretely whether the father of the father of john is mark.
Here the proof actually does use equalities, but only for simplification.</p>
</div>

<p>Input file example8.txt:</p>

<pre><code id="example_8_input_code">%father(john,pete).
father(john) = pete.

%father(pete,mark).
father(pete) = mark.

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
%-father(X,Y) | -father(Y,Z) | grandfather(X,Z).
grandfather(father(father(X)),X).

-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).

father(father(john)) != mark.
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example8.txt
by run 1 fork 0 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":0}

proof:
 1: [in, axiom] -=(father(father(john)),mark).
 2: [in, axiom] =(father(john),pete).
 3: [in, axiom] =(father(pete),mark).
 4: [simp, 1, 2, 3, fromaxiom] false
</code></pre>
<div id="example_8_proof_notes">
<p>Observe that gkc outputs equalities in a prefix form: instead of
infix a=b it writes =(a,b). These two forms have the same meaning
for gkc: you could use both.</p>

<p>Negation of equality can be also written either in the infix form as</p>

<pre><code>a!=b
</code></pre>

<p>or in the prefix form as</p>

<pre><code>-=(a,b)
</code></pre>

<p>The last step of the proof uses the <code>simp</code> rule which here replaces 
father(john) subterm in the -=(father(father(john)),mark) statement with
pete using the equality at step 2, 
giving -=(father(pete),mark), which then contradicts the step 3.</p>
</div>

<div id="example_9_input_notes"><h3>Example 9 for reflexivity used in proof</h3>

<p>We will ask the same question as in the previous example, but this time
using the $ans predicate to find a grandfather of john. </p>
</div>
<p>Input file example9.txt:</p>

<pre><code id="example_9_input_code">%father(john,pete).
father(john) = pete.

%father(pete,mark).
father(pete) = mark.

% equivalent to (father(X,Y) &amp; father(Y,Z)) =&gt; grandfather(X,Z).
%-father(X,Y) | -father(Y,Z) | grandfather(X,Z).
grandfather(father(father(X)),X).

-ancestor(X,Y) | -ancestor(Y,Z) | ancestor(X,Z).

father(father(john)) != X | $ans(X).
</code></pre>

<p>Output:</p>

<pre><code>result: proof found
for example9.txt
by run 2 fork 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}

answer: $ans(mark).
proof:
 1: [in, axiom] -=(father(father(john)),?0) | $ans(?0).
 2: [in, axiom] =(father(john),pete).
 3: [in, axiom] =(father(pete),mark).
 4: [simp, 1, 2, 3, fromaxiom] -=(mark,X) | $ans(X).
 5: [r=, 4.0, fromaxiom] $ans(mark).
</code></pre>
<div id="example_8_proof_notes">
<p>Here the proof uses the reflexivity rule <code>r=</code> which is basically the
standard property of equality: `X=X'.</p>
</div>

<div id="example_10_input_notes"><h3>Example 10 for multiple answers</h3>

<p>Now let us look at how to get several answers, not just one.
We will also introduce mothers and a mother-side grandfather
rule.</p>


  We will also use a separate json-syntax strategy file multineg.txt
  in the same folder to tell gkc specific details of what
  to look for and how.</p>
  
  <p>The <code>"max_answers":2</code> part tells gkc that it should
  try to find at least 2 answers and stop after that.</p>
  
  <p>The "strategy": ["negative_pref"] indicates that one specific
  strategy (here a conventional negative-preference ordered binary resolution)
  is to be used for proof search, without any parallel or sequential attempts
  with different search strategies.</p>
  
<p>multineg.txt file:</p>

<pre><code>{
"max_answers":2,
"strategy": ["negative_pref"]
}
</code></pre>

Please click on the <b>Advanced</b> button above and copy-paste the multineg.txt json 
into the <b>Strategy</b> box, then click <b>Prove.</b>
</div>
<!--
  <p>And you should run gkc like this to make it use the multineg.txt strategy file:</p>
  
  <pre><code>./gkc example10.txt multineg.txt
  </code></pre>
-->
 
  <p>Output:</p>

<p>Input:</p>

<pre><code id="example_10_input_code">father(john) = pete.
father(mike) = pete.
mother(john) = eve.
mother(mike) = eve.

father(pete) = mark.
mother(eve) = mary.

grandfather(father(father(X)),X).
grandfather(father(mother(X)),X).

-grandfather(mark,X) | $ans(X).
</code></pre>


<pre><code>result: proof found
for example10.txt

answers and proofs:

answer: $ans(mike).
proof:
 1: [in, axiom] =(father(mike),pete).
 2: [in, axiom] grandfather(father(father(X)),X).
 3: [=, 1, 2.0.2, fromaxiom] grandfather(father(pete),mike).
 4: [in, axiom] =(father(pete),mark).
 5: [simp, 3, 4, fromaxiom] grandfather(mark,mike).
 6: [in, axiom] -grandfather(mark,X) | $ans(X).
 7: [mp, 5, 6, fromaxiom] $ans(mike).

answer: $ans(john).
proof:
 1: [in, axiom] =(father(john),pete).
 2: [in, axiom] grandfather(father(father(X)),X).
 3: [=, 1, 2.0.2, fromaxiom] grandfather(father(pete),john).
 4: [in, axiom] =(father(pete),mark).
 5: [simp, 3, 4, fromaxiom] grandfather(mark,john).
 6: [in, axiom] -grandfather(mark,X) | $ans(X).
 7: [mp, 5, 6, fromaxiom] $ans(john).
</code></pre>

<div id="example_10_proof_notes">
<p>The [=, 1, 2.0.2, fromaxiom] means that the clause at step 1 was used to replace a 2th subterm
(numbering 0,1,2,...) of the 0th atom of a clause at step 2 using equality.</p>

<p>Observe that the two answers have (obviously) different proofs.</p>

<p>Importantly, gkc will not really attempt to find two different <code>$ans(...)</code> answers,
but two different proofs, which could (or not, as in our case) actually lead to
the same <code>$ans(...)</code> answers.</p>

<p>Try to modify the multineg.txt file to ask for three answers: "max_answers":3,
and then run gkc again. It will give the same output as before, but will add the 
last line at the end:</p>

<pre><code>result: proof not found.
</code></pre>

<p>essentially indicating that the required number of different proofs (3) were not found.  </p>

<div id="example_11_input_notes"><h3>Example algebra</h3>

<p>Next we will take a question from abstract algebra,
axiomatized wholly by equalities.</p>
</div>
<pre><code id="example_11_input_code">% A question from abstract algebra. Here m is an arbitrary binary
% operation (similar to arithmetic multiplication) for 
% which the following three axioms hold.

m(X,i(X)) = e .   % i is an inverse function like one divided by X
m(X,e) = X .      % e is a unit element like 1 when on the right side
m(X,m(Y,Z)) = m(m(X,Y),Z) . % m is an associative operation

% Question: is e also a unit element when it is on the left
% side of multiplication m?
%
% We get the following clause by negating `forall X. m(e,X) = X`
% as `exists X. m(e,X) != X`
% and using an arbitrary unknown constant `c` for existentially 
% quantified `X`.
% In short, if the next clause gives contradiction, then it will
% also give a contradiction for anything you can put in place of `c`.

m(e,c) != c .
</code></pre>

<pre><code>result: proof found
  for algebra.txt
  by run 3 fork 2 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1,"weight_select_ratio":20}
  
  proof:
   1: [in, axiom] =(m(X,i(X)),e).
   2: [in, axiom] =(m(X,m(Y,Z)),m(m(X,Y),Z)).
   3: [=, 1, 2.0.3, fromaxiom] =(m(X3,e),m(m(X3,Y3),i(Y3))).
   4: [in, axiom] =(m(X,e),X).
   5: [simp, 3, 4, fromaxiom] =(X,m(m(X,Y),i(Y))).
   6: [=, 1, 5.0.3, fromaxiom] =(X,m(e,i(i(X)))).
   7: [=, 5.0.R, 5.0.3, fromaxiom] =(m(X,Y),m(X,i(i(Y)))).
   8: [in, axiom] -=(m(e,c),c).
   9: [=, 6.0.R, 7.0.4, 8, fromaxiom] false
  </code></pre>

<div id="example_11_proof_notes"></div>
<p>The proof uses given equalities to derive several new equalities.
The <code>=</code> rule basically replaces parts of one premiss matching (unifying)
one side of the second premiss equality with the other side of the equality.</p>

<p>The <code>simp</code> rule also replaces a part of a premiss, but does so in a <code>permanent</code> manner,
meaning that the original unchanged premiss is not used in the search after
the simplification replacement.</p>

<p>The [=, 1, 2.0.3, fromaxiom] means that the clause at step 1 was used to replace a 3th subterm
(numbering 0,1,2,...) of the 0th atom of a clause at step 2 using equality.</p>

</div>

<div id="example_12_input_notes"><h3>Example with an unprovable problem</h3>

<p>A simple clause set </p>

<pre><code id="example_12_input_code">p(a).
-p(X) | p(f(X)).
</code></pre>

<p>in this example produces an unlimited number of clauses like</p>

<pre><code>p(f(a))
p(f(f(a)))
p(f(f(f(a)))
...
</code></pre>

<p>and obviously does not lead to a contradiction.</p>

<p>However, gkc does not attempt to detect unprovability and will
run either forever or for a very long time, until the browser complains
and asks you to stop, or it runs out of allocated time or memory.</p>
<p><b>NB!</b>You will have to <b>reload</b> the page after you stop the script, otherwise
the page will be unresponsive.</p>
<!--
<pre><code>./gkc example11.txt
</code></pre>

<p>will produce no output for quite some time.</p>
<div id="example_12_proof_notes">

<p>Running gkc with the -tptp 1 parameter added will cause it
to produce a lot of output, indicating the progress of proof
search runs. Try it:</p>
</div>


<pre><code>./gkc example11.txt -tptp 1
</code></pre>

<p>and you will see that for some strategies
gkc terminates very quickly, while for others it runs until the
given time is out.</p>
</div>
-->
<div id="example_13_input_notes"><h3>Example with a hard problem</h3>

<p>As an example of a small but a really hard problem for gkc which is
nevertheless actually provable, try the fof-format problem 
<a href="example12.txt">example12.txt</a> (LCL876+1 from the TPTP collection):</p>

<p>It will probably run until the browser complains badly 
or time given by the automatic strategy selection runs out.</p>

<p><b>NB!</b>You will have to <b>reload</b> the page after you stop the script, otherwise
  the page will be unresponsive.</p>

<!--
<p>You can check out </p>

<pre><code>./gkc example12.txt -tptp 1
</code></pre>

<p>to see the progress.</p>
-->
<p>Of course, it is likely that with a suitable search strategy
gkc will find a proof in a sensible amount of time and memory. Currently
we are simply unaware of which strategy it would be!</p>

<p>Using a time limit like</p>

<pre><code>./gkc example12.txt -seconds 20
</code></pre>

<p>is useful to avoid very long runs.</p>
</div>
<h3>Examples with medium-hard blocks world problems</h3>

<p><a href="https://en.wikipedia.org/wiki/Blocks_world">Blocks world</a>
is a classic family of toy problems: there is a robot arm
able to lift single blocks and to put them on top of other blocks.</p>

<p>The goal is to find a sequence of robot arm movements to produce
a required configuration of blocks: for example, a tower.</p>

<p>Without a specialized search strategy these planning problems
tend to be surprisingly hard for provers, including gkc.</p>

<p>Try out progressively harder versions of the blocks world problem:</p>

<pre><code>./gkc blocks1.txt
./gkc blocks2.txt
./gkc blocks3.txt
./gkc blocks4.txt
./gkc blocks5.txt
</code></pre>

<p>All of these are modified versions of each other: some goals
at the end of the file are commented out while one is kept.</p>

<p>Look into any of these files (say, <a href="blocks1.txt">blocks1.txt</a>)
to see an explanation of what facts and rules there are and how is the task encoded.</p>

<p>The first and second problems are easy, third and fifth should take a few seconds,
the fourth ca one minute. The only difference between the third and fourth
is that the fourth asks for an actual answer, while the third only asks 
whether an answer exists. Clearly there is room for improving the answer-finding
efficiency of gkc!</p>

<p>In the <a href="#Advanced-examples">advanced examples chapter</a>we will look at guiding gkc search by using
a strategy selection file. A suitable simple strategy for the third example 
is given in the file blocks_strat2.txt:</p>

<pre><code>{
  "print_level": 10,     
  "max_seconds": 5,
  "strategy":["query_focus"],
  "query_preference": 2
}
</code></pre>

<p>and for the fifth in the file blocks_strat3.txt:</p>

<pre><code>{
  "max_seconds":5,
  "strategy":["query_focus"],
  "query_preference":1
}
</code></pre>

<p>Using these as</p>

<pre><code>./gkc blocks3.txt blocks_strat2.txt -parallel 0
./gkc blocks5.txt blocks_strat3.txt -parallel 0
</code></pre>

<p>gives us proofs in ca 50 milliseconds and 300 milliseconds, respectively.</p>

<p>Looking at the output of the fourth we see
that it uses a strategy {"max<em>seconds":25,"strategy":["unit"],"query</em>preference":1}
which we can put into our strategy file blocks_strat.txt </p>

<pre><code>{
  "max_seconds":25,
  "strategy":["unit"],
  "query_preference":0
}
</code></pre>

<p>to get the proof in ca eight seconds:</p>

<pre><code>./gkc blocks4.txt blocks_strat.txt -parallel 0
</code></pre>

<p>There is a lot of interesting research on the topic of
<a href="https://ai.dmi.unibas.ch/_files/teaching/hs12/search-opt-seminar/slides/08_blocks_world_revisited.pdf">improving blocks world planning</a>.</p>

<h2>Advanced examples</h2>

<p>Next we will look at richer input languages and more advanced capabilities of gkc. </p>

<p>Topics considered:
* <a href="#Whitespace-variables-numbers-encodings">Whitespace variables numbers encodings</a>
* <a href="#Included-files-and-mixing-simple-syntax-with-fof-and-cnf-syntax">Included files and mixing simple syntax with fof and cnf syntax</a>
* <a href="#Example-for-TPTP-fof-syntax-with-steam">Example for TPTP fof syntax with steam</a>
* <a href="#Example-for-steam-with-a-shared-memory-database">Example for steam with a shared memory database</a>
* <a href="#Example-for-steam-with-the-TPTP-format-output">Example for steam with the TPTP format output</a>
* <a href="#Telling-gkc-what-is-actually-the-question-clause-in-input">Telling gkc what is actually the question clause in input</a>
* <a href="#Directing-the-prover-and-changing-the-settings">Directing the prover and changing the settings</a>
* <a href="#Example-with-json-output">Example with json output</a>
* <a href="#Examples-with-arithmetic">Examples with arithmetic</a>
* <a href="#Large-theory-batch-files">Large theory batch files</a></p>

<p>Several examples will use the fof (first order formula) syntax used by
the TPTP project:</p>

<ul>
<li><a href="http://www.tptp.org/">TPTP project</a></li>
<li><a href="http://tptp.org/TPTP/TR/TPTPTR.shtml#FormulaeSection">fof syntax</a></li>
<li><a href="http://www.tptp.org/cgi-bin/SeeTPTP?Category=Problems&amp;Domain=SYN&amp;File=SYN000+1.p">fof example</a></li>
</ul>

<h3>Whitespace variables numbers encodings</h3>

<p>This is not a really advanced topic, but important.</p>

<p>A normal symbol must not contain any whitespace or non-alphanumeric characters
like (, -, ~, =, ", dollar $, comma etc: however, undercore _ is allowed.</p>

<p>You can put whitespace or any symbol except a single quote
into symbols by surrounding the symbol with single quote symbols like this:</p>

<pre><code>'john smith'
</code></pre>

<p>which is treated as a constant, whereas 'John smith' will be treated
as a variable, since it still starts with a capital letter, even though
quoted.</p>

<p>Any symbol containing a character except an ascii letter, digit, underscore _,
or dollar $ will be printed out by surrounding it with single quotes.
As an exception, equality = and aritmetic expressions +, *, -, /, &lt; will 
not be surrounded by quotes. </p>

<p>Additionally you can make a symbol variable by prefixing it with a question
mark like this:</p>

<pre><code>?smth
</code></pre>

<p>As said before, any symbol starting with a capital letter or a question mark 
is assumed to be a variable, and the rest are not. </p>

<p>This holds for both the simple syntax in the previous examples and the 
fof formulas to be described next. </p>

<p>Thus, in fof formulas a capital-letter-starting symbol is a variable even if
it is not explicitly quantified: since this will easily be confusing, it
is better to avoid such symbols unless they are explicitly quantified.</p>

<p>You can also use integers like 71 or period-separated decimals like 1.35
as constants.</p>

<p>Gkc is agnostic towards using different character encodings: it uses
c-strings, i.e. 0-terminated byte sequences and does not care about encodings.</p>

<h3>Included files and mixing simple syntax with fof and cnf syntax</h3>

<p>Problems may contain several include statements like</p>

<pre><code>include('Axioms/GEO004+2.ax').
include('steam_kb.txt').
</code></pre>

<p>in which case the included path is searched sequentially from the following
locations until found:
* in the folder of the input problem path,
* in the folder indicated by the environment variable TPTP,
* in the folder /opt/TPTP.</p>

<p>When an included file is found, its contents are treated as if they were a part of the
main problem file. The include file may again contain includes. When an include file
is not found, gkc will output an error and stop.</p>

<p>The fof and cnf syntax described in the following section can be mixed with the
simple syntax as in example13.txt:</p>

<pre><code>include('steam_kb.txt'). % this is an include statement

fof(a1, axiom, ( ! [X] : (wolf(X) =&gt; dangerous(X)))). % this is fof
cnf(a2, axiom, (~dangerous(Y) | ~good(Y))). % this is cnf

good(Z). % this is a simple syntax (saying that everything is good)
</code></pre>

<p>Running ./gkc example13.txt will output:</p>

<pre><code>result: proof found
for example13.txt
by run 3 fork 2 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}

proof:
1: [in,a1, axiom] -wolf(X) | dangerous(X).
2: [in,a2, axiom] -good(XX0) | -dangerous(XX0).
3: [in, axiom] good(XX0).
4: [simp, 2, 3, fromaxiom] -dangerous(X).
5: [in,$imp::pel47_1_2, extaxiom] wolf($sk7).
6: [mp, 1.1, 4, 5, fromaxiom] false
</code></pre>

<p>where <code>[in,$imp::pel47_1_2, extaxiom]</code> indicates that the statement with the
name <code>pel47_1_2</code> was in one of the imported files. </p>

<p>For a search strategy with a setting "query_preference": 2, 
gkc treats imported axioms as having a bit lower priorities
than the statements in the main file. For all the other strategies being
imported or not does not make a difference, although in the general case the order of clauses
may sometimes cause minor unpredictable differences in proof search.</p>

<p>The example also shows that when printing clauses, gkc does not generally use the same variable
names as in the input file. Expect it to prefer variable names X,Y,Z,U,V,W (optionally
followed by a number) in the printout. For input clauses the variables are sometimes
printed as XXN for some number N.</p>

<h3>Example for TPTP fof syntax with steam</h3>

<p>The steam.txt file contains a classic "Schubert's Steamroller" puzzle taken from
TPTP and written in fof syntax with connectives like implication =&gt;, quantifiers forall ! [X] ..,
exists ? [X] ... etc. 
See the official <a href="http://tptp.org/TPTP/TR/TPTPTR.shtml#FormulaeSection">fof syntax</a> and
<a href="http://www.tptp.org/cgi-bin/SeeTPTP?Category=Problems&amp;Domain=SYN&amp;File=SYN000+1.p">fof example</a>
in <a href="http://www.tptp.org">TPTP</a>.</p>

<p>Gkc will first convert the complex formulas to a simple clause form (properly called
clause normal form) used in the previous examples. The statements we had in these
examples are called <code>clauses</code>. </p>

<p>The first part of the <a href="steam.txt">steam.txt</a> file contains comments describing the problem.
The rest contains full first order formulas like </p>

<pre><code>fof(pel47_1_1,axiom,
    ( ! [X] :
        ( wolf(X)
       =&gt; animal(X) ) )).

fof(pel47_1_2,axiom,
    ( ? [X1] : wolf(X1) )).

fof(pel47,conjecture,
    ( ? [X,Y] :
        ( animal(X)
        &amp; animal(Y)
        &amp; ? [Z] :
            ( grain(Z)
            &amp; eats(Y,Z)
            &amp; eats(X,Y) ) ) )).
</code></pre>

<p>Each statement is terminated with a period symbol . and has a structure</p>

<pre><code>fof(statement_name, statement_role, statement).
</code></pre>

<p>where the statement<em>name will be used in the proof, the statement</em>role indicates whether
it is an axiom, an assumption or hypothesis, or a goal to be proved from these: the latter is either
conjecture (which has to be negated) or negated_conjecture (negated already).</p>

<p>Indicating the role enables provers to find a more suitable strategy. It does not (except the
conjecture case, which has to be negated) have a <code>logical</code> meaning.</p>

<p>The first example statement above is universally quantified (! symbol) and will be converted by gkc to a clause</p>

<pre><code>-wolf(X) | animal(X).
</code></pre>

<p>The second statement is existentially quantified (? symbol) and will be converted by gkc to a clause</p>

<pre><code>wolf($sk7).
</code></pre>

<p>where $sk7 is a new constant invented by gkc which should not occur in any other formula in the problem:
this procedure is called <a href="https://en.wikipedia.org/wiki/Skolem_normal_form">Skolemization</a>.
Gkc always uses the $sk prefix for such constants and functions, using a new number N for each
new one. The original formula is assumed not to contain $skN form symbols.</p>

<p>The third statement expresses the question to be proved: is 
there an animal that likes to eat a grain eating animal?
It has a conjecture role and has to be first negated and then converted to 
clauses:</p>

<pre><code>-eats(X,Y) | -eats(Z,X) | -grain(Y) | -animal(X) | -animal(Z).
</code></pre>

<p>In general, one formula in the input may create several clauses and the optimized
algorithm for creating such clauses is nontrivial, sometimes involving mini-scoping and the creation of new
definitions (new predicates) to make the size and number of generated clauses smaller.</p>

<p>Ask gkc to prove steam.txt without using parallel processes:</p>

<pre><code>./gkc steam.txt -parallel 0
</code></pre>

<p>producing output:</p>

<pre><code>result: proof found
for steam.p
by run 1 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":1}

proof:
 1: [in,pel47_7, axiom] -much_smaller(X,Y) | -eats(X,Z) | eats(Y,U) | eats(Y,X) | -plant(U) | -plant(Z) | -animal(X) | -animal(Y).
 2: [in,pel47_6_2, axiom] -grain(X) | plant(X).
 3: [in,pel47_6_1, axiom] grain($sk2).
 4: [mp, 2, 3, fromaxiom] plant($sk2).
 5: [mp, 1.4, 4, fromaxiom] -much_smaller(X,Y) | -eats(X,Z) | eats(Y,$sk2) | eats(Y,X) | -plant(Z) | -animal(Y) | -animal(X).
 6: [in,pel47_14, axiom] plant($sk1(X)) | -snail(X).
 7: [in,pel47_5_2, axiom] snail($sk3).
 8: [mp, 6.1, 7, fromaxiom] plant($sk1($sk3)).
 9: [mp, 5.4, 8, fromaxiom] -eats(X,$sk1($sk3)) | -much_smaller(X,Y) | eats(Y,$sk2) | eats(Y,X) | -animal(Y) | -animal(X).
 10: [in,pel47_14, axiom] eats(X,$sk1(X)) | -snail(X).
 11: [mp, 10.1, 7, fromaxiom] eats($sk3,$sk1($sk3)).
 12: [in,pel47_5_1, axiom] -snail(X) | animal(X).
 13: [mp, 12, 7, fromaxiom] animal($sk3).
 14: [mp, 9, 11, 13, fromaxiom] -much_smaller($sk3,X) | eats(X,$sk2) | eats(X,$sk3) | -animal(X).
 15: [in,pel47_8, axiom] much_smaller(X,Y) | -snail(X) | -bird(Y).
 16: [mp, 15.1, 7, fromaxiom] much_smaller($sk3,X) | -bird(X).
 17: [in,pel47_3_2, axiom] bird($sk5).
 18: [mp, 16.1, 17, fromaxiom] much_smaller($sk3,$sk5).
 19: [in,pel47_3_1, axiom] -bird(X) | animal(X).
 20: [mp, 19, 17, fromaxiom] animal($sk5).
 21: [mp, 14, 18, 20, fromaxiom] eats($sk5,$sk3) | eats($sk5,$sk2).
 22: [merge, 1.4.5, fromaxiom] -much_smaller(X,Y) | -eats(X,Z) | eats(Y,Z) | eats(Y,X) | -plant(Z) | -animal(Y) | -animal(X).
 23: [mp, 22.4, 4, fromaxiom] -much_smaller(X,Y) | -eats(X,$sk2) | eats(Y,$sk2) | eats(Y,X) | -animal(Y) | -animal(X).
 24: [mp, 21.1, 23.1, 20, fromaxiom] eats($sk5,$sk3) | -much_smaller($sk5,X) | eats(X,$sk2) | eats(X,$sk5) | -animal(X).
 25: [in,pel47_9, axiom] much_smaller(X,Y) | -bird(X) | -fox(Y).
 26: [mp, 25.1, 17, fromaxiom] much_smaller($sk5,X) | -fox(X).
 27: [in,pel47_2_2, axiom] fox($sk6).
 28: [mp, 26.1, 27, fromaxiom] much_smaller($sk5,$sk6).
 29: [in,pel47_2_1, axiom] -fox(X) | animal(X).
 30: [mp, 29, 27, fromaxiom] animal($sk6).
 31: [mp, 24.1, 28, 30, fromaxiom] eats($sk6,$sk5) | eats($sk5,$sk3) | eats($sk6,$sk2).
 32: [in,pel47_13, axiom] -eats(X,Y) | -snail(Y) | -bird(X).
 33: [mp, 32.1, 7, fromaxiom] -eats(X,$sk3) | -bird(X).
 34: [in,pel47_3_2, axiom] bird($sk5).
 35: [mp, 31.1, 33, 34, fromaxiom] eats($sk6,$sk5) | eats($sk6,$sk2).
 36: [mp, 35.1, 23.1, 30, fromaxiom] eats($sk6,$sk5) | -much_smaller($sk6,X) | eats(X,$sk2) | eats(X,$sk6) | -animal(X).
 37: [in,pel47_10, axiom] much_smaller(X,Y) | -fox(X) | -wolf(Y).
 38: [mp, 37.1, 27, fromaxiom] much_smaller($sk6,X) | -wolf(X).
 39: [in,pel47_1_2, axiom] wolf($sk7).
 40: [mp, 38.1, 39, fromaxiom] much_smaller($sk6,$sk7).
 41: [in,pel47_1_1, axiom] -wolf(X) | animal(X).
 42: [mp, 41, 39, fromaxiom] animal($sk7).
 43: [mp, 36.1, 40, 42, fromaxiom] eats($sk7,$sk6) | eats($sk6,$sk5) | eats($sk7,$sk2).
 44: [in,pel47, goal] -eats(X,Y) | -eats(Z,X) | -grain(Y) | -animal(X) | -animal(Z).
 45: [mp, 3, 44.2, fromgoal] -eats(X,Y) | -eats(Y,$sk2) | -animal(X) | -animal(Y).
 46: [mp, 21.1, 45.1, 20, fromgoal] eats($sk5,$sk3) | -eats(X,$sk5) | -animal(X).
 47: [mp, 43.1, 46.1, 30, fromgoal] eats($sk7,$sk6) | eats($sk7,$sk2) | eats($sk5,$sk3).
 48: [mp, 47.2, 33, 34, fromgoal] eats($sk7,$sk6) | eats($sk7,$sk2).
 49: [in,pel47_11, axiom] -eats(X,Y) | -grain(Y) | -wolf(X).
 50: [mp, 49.1, 3, fromaxiom] -eats(X,$sk2) | -wolf(X).
 51: [in,pel47_1_2, axiom] wolf($sk7).
 52: [mp, 48.1, 50, 51, fromgoal] eats($sk7,$sk6).
 53: [in,pel47_11, axiom] -eats(X,Y) | -fox(Y) | -wolf(X).
 54: [mp, 53.1, 27, fromaxiom] -eats(X,$sk6) | -wolf(X).
 55: [mp, 52, 54, 51, fromgoal] false
</code></pre>

<p>The proof contains only clauses created from the formulas: the original names of formulas used are indicated 
like</p>

<pre><code>[in,pel47_1_2, axiom] wolf($sk7).
</code></pre>

<p>Since the steamroller puzzle is a fairly easy problem for provers, several different search strategies
are able to solve it very quickly. Thus, if you run the gkc without the -parallel 0 parameter on UNIX,
four parallel processes are created with different search strategies, which start to run at approximately
the same time and it sometimes happens that one finishes first, while at other times another one may 
finish first. Thus you may get a different output in a somewhat unpredictable manner, for example</p>

<pre><code>result: proof found
for steam.p
by run 3 fork 2 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}
...
</code></pre>

<p>or</p>

<pre><code>result: proof found
for steam.p
by run 4 fork 3 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":0}
...
</code></pre>

<p>where <code>run N</code> indicates the strategy used (numeration 1,2,...) and <code>fork M</code> indicates which parallel
process found it (numeration 0,1,2,..). The run number N and the fork number M have a strict
correspondence: the order by which runs are given to forks is pre-determined.</p>

<p>The proofs found by different strategies are likely also somewhat different.</p>

<p>As said before, gkc implements parallel processes using forks and only for UNIX, i.e. Linux and OS X.</p>

<h3>Example for steam with a shared memory database</h3>

<p>Examples in this section behave somewhat differently on Linux and
Windows, and do not function on OS X (maxOS): more about this below.</p>

<p>Very large axiom sets take a long time to parse and index. In case you have many different questions
to ask, which all use the same large axiom set, it makes sense to parse, convert and index 
the axiom set before the questions are asked, so that each individual question does not
have to go through that process.</p>

<p>In order to try this, there are two files created from steam.txt:
* steam<em>kb.txt contains all axioms in steam.txt, but not the conjecture,
* steam</em>query.txt contains only the conjecture.</p>

<p>Read in an axiom set into persistant shared memory like this:</p>

<pre><code>./gkc -readkb steam_kb.txt
</code></pre>

<p>which parses, converts and indexes the file steam_kb.txt, outputs</p>

<pre><code>Data parsed into the shared memory db, starting to build indexes.
Db ready in shared memory.
</code></pre>

<p>does not attempt to prove anything and stops.</p>

<p>Since steam_kb.txt is a small file, loading it into memory does not really make proof
search noticeably faster. Large axiom sets like 
<a href="http://www.tptp.org/cgi-bin/SeeTPTP?Category=Axioms&amp;File=CSR002+5.ax">CSR002+5.ax in TPTP</a>
contain several million statements: parsing and indexing this file takes ca 30
seconds for gkc.</p>

<p>You can then start asking questions from this persistant memory image like this:</p>

<pre><code>./gkc -provekb steam_query.txt
</code></pre>

<p>Observe that even for such a small problem, the proof will be found faster,
in a few milliseconds, as opposed to ca 70 milliseconds for the original
proof without the prepared memory database.</p>

<p>On Windows, the same machinery has additional requirements: </p>

<p>First, the default amount of memory requested by gkc may be too large: run</p>

<pre><code>gkc -readkb steam_kb.txt -mbsize 1000
</code></pre>

<p>to ask for just 1GB of memory. Second, the process does NOT stop, but says</p>

<pre><code>Shared memory kb is available while this program is running.
Press any key to free shared memory kb and exit . . .
</code></pre>

<p>and waits. Shared memory database is available while the process
is still waiting, but once it is stopped, the database is no longer available. Thus
on Windows the machinery has to be run in two separate command line windows.</p>

<p>OS X severely restricts the size of the shared memory and it is really
complicated to change the restriction. Hence you may simply assume the
shared memory functionality of gkc is not available on OS X.</p>

<p>On UNIX, once the memory database is no longer needed, delete it by doing</p>

<pre><code>./gkc -deletekb
</code></pre>

<p>It is possible to have a number of different shared memory databases available at
the same time. Thus the databases have a number, which by default is 1000.</p>

<p>To indicate which shared memory database should be loaded, used or deleted,
use the optional <code>-mbnr &lt;shared memory database nr&gt;</code> parameter like this:</p>

<pre><code>./gkc -readkb steam_kb.txt -mbnr 1001
./gkc -provekb steam_query.txt -mbnr 1001
./gkc -deletekb -mbnr 1001
</code></pre>

<p>Only one memory database at a time can be used for answering one particular query.</p>

<p>It is also possible to write the present shared memory database to a file for 
faster loading later:</p>

<pre><code>./gkc -writekb &lt;dump file&gt;
</code></pre>

<p>and then read it in later by doing:</p>

<pre><code>./gkc -loadkb &lt;dump file&gt;
</code></pre>

<p>thus avoiding the prolonged parsing/converting/indexing process of reading
a large file of statements.</p>

<p>As a base technology for both the shared memory database and 
its internal representation of data gkc uses <a href="http://whitedb.org">Whitedb</a>.</p>

<h3>Example for steam with the TPTP format output</h3>

<p>The simple output format used in all the previous examples does not directly contain
the original input formulas of the fof language of TPTP and the steps in conversion, 
only the names of the formulas. Additionally, TPTP suggests using a particular
format of output, including proved-successfully-marker and the begin and end
of proof.</p>

<p>To use the TPTP suggested output format, say:</p>

<pre><code>./gkc steam.txt -tptp 1
</code></pre>

<p>which will both use the TPTP format for proofs and will also write
more information about the problem, strategies selected, search process
and statistics. The latter are not really required by the TPTP format, but
gkc will add these anyway.</p>

<p>We will not write the whole output here. The parts are:</p>

<ul>
<li>Statistics about the clauses obtained by conversion.</li>
<li>Selected strategies to be run in json format.</li>
<li>Running overview of proof search, just to follow what is happening.</li>
<li>Proof in the TPTP format.</li>
<li>Statistics about the successful search.</li>
</ul>

<p>The proof itself has the following structure:</p>

<pre><code>result: proof found
by run 1 strategy {"max_seconds":1,"strategy":["negative_pref"],"query_preference":1}
% SZS status Theorem for steam.p.

% SZS output start CNFRefutation for steam.p
..

fof('pel47_6_2_$sk', plain, (plant(X1) | ~grain(X1)),
  inference(negpush_and_skolemize,[],['pel47_6_2'])).
fof('pel47_6_2', axiom, (! [X1] : (grain(X1) =&gt; plant(X1))),
  input). 
fof('pel47_6_1_$sk', plain, grain($sk2),
  inference(negpush_and_skolemize,[],['pel47_6_1'])).
fof('pel47_6_1', axiom, (? [X] : grain(X)),
  input). 
...
cnf('2', plain, (~grain(X) | plant(X)),
  inference(cnf_transformation,[],['pel47_6_2_$sk'])).
cnf('3', plain, (grain($sk2)),
  inference(cnf_transformation,[],['pel47_6_1_$sk'])).
...
cnf('11', plain, (eats($sk3,$sk1($sk3))),
  inference(resolution,[],['10','7'])).
cnf('12', plain, (~snail(X) | animal(X)),
  inference(cnf_transformation,[],['pel47_5_1_$sk'])).  
...
cnf('55', plain, ($false),
  inference(resolution,[then_simplify],['52','54','51'])).
% SZS output end CNFRefutation for steam.p
</code></pre>

<p>where each statement has either a form with a fof-formula</p>

<pre><code>fof(formula_name, formula_role, formula, 
    conversion_rule_and_sources).
</code></pre>

<p>or a form with a simple clause</p>

<pre><code>cnf(formula_name, plain, clause, 
    derivation_rule_and_sources).
</code></pre>

<p>The cnf-statements are also allowed in the TPTP format as valid input.</p>

<p>The first block with fof formulas contains the input formulas after some trivial
simplifications along with one intermediate step of pushing negation inwards and skolemizing
like</p>

<pre><code>inference(negpush_and_skolemize,[],['pel47_6_1'])).
</code></pre>

<p>The second block contains cnf clauses, which are either input like
    inference(cnf<em>transformation,[],['pel47</em>6<em>1</em>$sk'])) 
or derived by proof search like
    inference(resolution,[then_simplify],['52','54','51'])).</p>

<p>The cnf clauses are the same clauses as output by the simple default format,
just presented in the TPTP language along with the TPTP-style derivation step
and source information.</p>

<h3>Telling gkc what is actually the question clause in input</h3>

<p>Gkc does not know which clause is a question: this is ok,
but it is bad for efficiency in case of large clause sets.</p>

<p>There is a simple way to tell gkc that some clause or a formula is indeed a question
and gkc should heavily focus on that clause or a formula.</p>

<p>Instead of writing your negated question like</p>

<pre><code>-father(john,pete).
</code></pre>

<p>write it with this wrapping  as a fof formula (observe double parentheses at the end)</p>

<pre><code>fof(q1,negated_conjecture,
    -father(john,pete)).
</code></pre>

<p>or a cnf formula (i.e. simple clause) in TPTP language</p>

<pre><code>cnf(q1,negated_conjecture,
    -father(john,pete)).
</code></pre>

<p>and then gkc knows that this clause should get priority in search.</p>

<p>Similarly, you can tell gkc that a clause or a formula is not just
an arbitrary axiom which may or may not be used, but an important
assumption likely to be used in the proof:</p>

<pre><code>cnf(a1,assumption,
    person(john)).
</code></pre>

<p>These <code>negated_conjecture</code> and 'assumption` roles were already
mentioned previously when describing fof syntax: it is worth stressing
that they are useful and can be also intermingled with the simple
syntax.</p>

<h3>Directing the prover and changing the settings</h3>

<p>By default gkc automatically selects a number of strategies to run one-by one
and outputs either message that the proof was found along with the proof or a message
that no proof was found.</p>

<p>You can tell gkc the exact strategy and output level by writing a small
json strategy file strat.txt like this:</p>

<pre><code>{
  "print_level": 10,     
  "max_seconds": 60,
  "strategy":["query_focus"],
  "query_preference": 1
}
</code></pre>

<p>and then call the prover like this to make it use the strategy file:</p>

<pre><code>./gkc example1.txt strat.txt
</code></pre>

<p>There are two somewhat different ways to write the strategy file:
either indicate a single strategy (single run) like in the previous example,
or multiple runs like this:</p>

<pre><code>{
"print_level": 15,
"runs":[
{"max_seconds": 1,"strategy":["unit"],"query_preference":0},
{"max_seconds": 1,"strategy":["unit"],"query_preference":1},
{"max_seconds": 1,"strategy":["negative_pref"],"query_preference":0},
{"max_seconds": 1,"strategy":["negative_pref"],"query_preference":1},
{"max_seconds": 1,"strategy":["negative_pref"],"query_preference":0,"weight_select_ratio":100, "depth_penalty":100, "length_penalty":100},
{"max_seconds": 1,"strategy":["hardness_pref","posunitpara"],"query_preference":0,"weight_select_ratio":20,"depth_penalty": 50, "length_penalty":100},

{"max_seconds": 5,"strategy":["unit"],"query_preference":0},
{"max_seconds": 5,"strategy":["unit"],"query_preference":1},
{"max_seconds": 5,"strategy":["negative_pref"],"query_preference":0}
]
}
</code></pre>

<p>In the latter case gkc will try out all these strategies in that order, by default using the parallel processes 
so that each process gets a subsequence of these strategies.</p>

<p>A simple way to obtain such run sequences is to run</p>

<pre><code>./gkc example1.txt -tptp 1
</code></pre>

<p>which will then automatically construct and print out a suitable full strategy json
with many runs, which you can simply copy and paste into your own file for later modification.</p>

<p>The default value for limit-type fields starting with max_ is 0, indicating that no limit is set.</p>

<p>In case "equality": N is not set to 0, GKC uses reflexivity, paramodulation and demodulation 
with knuth-bendix ordering for handling equality.</p>

<p>The list "strategy": [...] contains the main search strategy indicators, default off:</p>

<ul>
<li>"query_focus" : use a goal-oriented set-of-support strategy with binary resolution</li>
<li>"negative_pref" : use binary resolution with negative literals preferred</li>
<li>"positive_pref" : use binary resolution with positive literals preferred</li>
<li>"hardness_pref" : use binary resolution with "hardest" (similar to weight) literals preferred</li>
<li>"knuthbendix_pref" : use binary resolution with knuth-bendix ordering of literals</li>
<li>"hyper" : use hyperresolution, with negative literals preferred</li>
<li>"posunitpara": perform paramodulation from units only</li>
<li>"prohibit<em>nested</em>para": disallow paramodulation if either parent is derived by paramodulation</li>
<li>"max<em>ground</em>weight": use the weight of the heaviest literal as the base weight of a clause</li>
<li>"unit", "double" or "triple" : use binary unit resolution or its generalization: (one of the arguments must be unit, a two-literal or three-literal clause, <br />
respectively. These may be added to the list in addition to the previous strategy indicators, for example, like ["query_focus","unit"].</li>
</ul>

<p>Other useful parameters, to be used outside the "strategy": [...] list:</p>

<ul>
<li>"print": 0 or 1, where 0 prohibits almost all printing, default 1.</li>
<li>"print_level": integer determining the level of output: useful values are between 0 and 50, default 10, for -tptp 1 gkc uses 15.</li>
<li>"print_json": 0 or 1, where 0 is default and 1 forces json output.</li>
<li>"print_tptp": 0 or 1, where 0 is default and 1 forces tptp-style proof output</li>
<li>"max<em>size", "max</em>length", "max<em>depth", "max</em>weight" indicate limits on kept clauses, defaults are 0.</li>
<li>"equality" : 1 or 0, with 1 being default and 0 prohibiting equality handling.</li>
<li>"rewrite" : 1 or 0, with 1 being default and 0 prohibiting using equations for rewriting.</li>
<li>"max_seconds": N being an integer limit of seconds for one run, default 0 (no limit).</li>
<li>"weight<em>select</em>ratio": N indicating the ratio of picking by order derived / clause weight, default is 5.</li>
<li>"max_answers": N indicating the maximal number of proofs searched for until search stops, default is 1.</li>
<li>"reverse_clauselist": N either default 0 or 1, where 1 follows the actual order for input clauses, starting from the end.</li>
<li>"sine": input filter with N either 1 or 2 where 1 is a less restrictive (accepts more clauses) and 2 more restrictive. NB! Sine is automatically switched off if the -provekb switch is used.</li>
<li>"depth_penalty": additional penalty for clause depth, default 1</li>
<li>"length_penalty": additional penalty for clause length, default 1</li>
<li>"var_weight": weight of a variable, default 5</li>
<li>"var_weight": weight of a repeated variable, default 7</li>
<li>"query_preference": N being 0, 1, 2 or 3 indicates which parts of the problem are treated as goals, assumptions or axioms:
  0 stands for no goal/assumption preference.
  1 stands for input preference (the assumption and conjecture formulas of fof)
  2 stands for making non-included formulas assumptions
  3 stands for considering only the negative clauses from conjecture to be goals</li>
</ul>

<p>For "max_seconds"&lt;2 gkc will automatically use immediate check for contradiction when a clause is derived. </p>

<h3>Example with json output</h3>

<p>Json output in gkc is experimental and will not always produce a correct result.
Gkc will produce json output if the strategy file contains a setting</p>

<pre><code>"print_json": 1
</code></pre>

<p>The clauses in answers and proofs will be still presented as
the simple language strings, not as json structures.</p>

<p>NB! The tptp language setting does not match well with the "print_json": 1
setting: using these together will produce a messy output, neither correct json
nor tptp output.</p>

<p>Given a multineg_json.txt file:</p>

<pre><code>{
"max_answers":2,
"print_json": 1,
"strategy": ["negative_pref"]
}
</code></pre>

<p>the previous example run</p>

<pre><code>./gkc example3.txt multineg_json.txt
</code></pre>

<p>will output a json structure:</p>

<pre><code>{"result": "proof found",

{"answers": [
[
{"answer": "$ans(mark)."},
{"proof":
[
[1, ["in", "axiom"], "-father(X,Y) | -father(Z,X) | grandfather(Z,Y)."],
[2, ["in", "axiom"], "father(pete,mark)."],
[3, ["mp", 1, 2, "fromaxiom"], "-father(X,pete) | grandfather(X,mark)."],
[4, ["in", "axiom"], "father(john,pete)."],
[5, ["mp", 3, 4, "fromaxiom"], "grandfather(john,mark)."],
[6, ["in", "axiom"], "-grandfather(john,X) | $ans(X)."],
[7, ["mp", 5, 6, "fromaxiom"], "$ans(mark)."]
]}
]
]}
}
</code></pre>

<h3>Examples with arithmetic</h3>

<p>Gkc supports integer and floating point arithmetic, but only in
a fairly limited and experimental way: do not be surprised if
something does not work as expected.</p>

<p>Arithmetic expressions may contain +, -, *, / and should be given 
in the infix form, like in</p>

<pre><code>p(1+2)
p((2*X)+1)
</code></pre>

<p>while the single arithmetic comparison operation <code>&lt;</code> except equality = 
should be given in the prefix form like</p>

<pre><code>&lt;(X,2).
</code></pre>

<p>or negated like</p>

<pre><code>-&lt;(X,2).
</code></pre>

<p>NB! In case a variable or a non-numeric constant is a first element of the 
arithmetic expression, you have to surround the variable or constant with single quotes,
like in</p>

<pre><code>p('X'*2)
</code></pre>

<p>otherwise the whole expression will be parsed as a single variable X*2.</p>

<p>First, a trivial example arithmetic0.txt:</p>

<pre><code>1=2.
</code></pre>

<p>As expected, gkc produces output:</p>

<pre><code>result: proof found
for arithmetic0.txt
by run 1 fork 0 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":1}

proof:
1: [in, axiom] =(1,2).
2: [simp, 1, fromaxiom] false
</code></pre>

<p>Observe that although it is obvious that 1!=2, ordinary non-numeric constants may
be equal even if different: </p>

<pre><code>a=b.
1=b.
</code></pre>

<p>does not lead to a contradiction!</p>

<p>Equality also works as expected when comparing floating point numbers:</p>

<pre><code>2.01!=2.01.
</code></pre>

<p>gives a contradiction, while a comparison of a floating point 2.0 and integer 2 does not:</p>

<pre><code>2.0!=2.
</code></pre>

<p>On the other hand, adding integer 1 to a floating point 1.0 gives a floating point 2.0
and the following input gives a contradiction:</p>

<pre><code>2.0!=1.0+1.
</code></pre>

<p>Both of the following comparison operations also produce a contradiction:</p>

<pre><code>&lt;(2,2.0).
&lt;(2.0,2).
</code></pre>

<p>Next we will take up rules and calculations.</p>

<p>Given an input file arithmetic1.txt:</p>

<pre><code>p(1).
-p(X) | p(1+X).
-p(10).
</code></pre>

<p>gkc produces output:</p>

<pre><code>result: proof found
for arithmetic1.txt
by run 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":0}

proof:
 1: [in, axiom] p(+(1,X)) | -p(X).
 2: [in, axiom] p(1).
 3: [mp, 1.1, 2, fromaxiom] p(2).
 4: [mp, 3, 1.1, fromaxiom] p(3).
 5: [mp, 4, 1.1, fromaxiom] p(4).
 6: [mp, 5, 1.1, fromaxiom] p(5).
 7: [mp, 6, 1.1, fromaxiom] p(6).
 8: [mp, 7, 1.1, fromaxiom] p(7).
 9: [mp, 8, 1.1, fromaxiom] p(8).
 10: [mp, 9, 1.1, fromaxiom] p(9).
 11: [in, axiom] -p(10).
 12: [mp, 10, 1.1, 11, fromaxiom] false
</code></pre>

<p>Observe that the proof is given in the prefix form, which is NOT 
how gkc wants to see arithmetic input!</p>

<p>Given input file arithmetic2.txt (observe quotes around X!):</p>

<pre><code>p(1).
-p(X) | p(('X'+1)*2).
-p(X) | X!=10 | $ans(X).
</code></pre>

<p>gkc produces output:</p>

<pre><code>result: proof found
for arithmetic2.txt
by run 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":0}

answer: $ans(10).
proof:
 1: [in, axiom] p(*(+(X,1),2)) | -p(X).
 2: [in, axiom] p(1).
 3: [mp, 1.1, 2, fromaxiom] p(4).
 4: [mp, 3, 1.1, fromaxiom] p(10).
 5: [in, axiom] -=(X,10) | -p(X) | $ans(X).
 6: [mp, 4, 5.1, fromaxiom] $ans(10).
</code></pre>

<p>Given input file arithmetic3.txt:</p>

<pre><code>p(2).
-p(X) | p(2*X).
-p(X) | &lt;(X,128).
</code></pre>

<p>gkc produces output:</p>

<pre><code>result: proof found
for arithmetic3.txt
by run 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":0}

proof:
 1: [in, axiom] p(*(2,X)) | -p(X).
 2: [in, axiom] p(2).
 3: [mp, 1.1, 2, fromaxiom] p(4).
 4: [mp, 3, 1.1, fromaxiom] p(8).
 5: [mp, 4, 1.1, fromaxiom] p(16).
 6: [mp, 5, 1.1, fromaxiom] p(32).
 7: [mp, 6, 1.1, fromaxiom] p(64).
 8: [mp, 7, 1.1, fromaxiom] p(128).
 9: [in, axiom] &lt;(X,128) | -p(X).
 10: [mp, 8, 9.1, fromaxiom] false
</code></pre>

<p>Given input file arithmetic4.txt using a floating point number:</p>

<pre><code>p(2.1).
-p(X) | p(2*X).
-p(X) | &lt;(X,128).
</code></pre>

<p>gkc produces output:  </p>

<pre><code>result: proof found
for arithmetic4.txt
by run 1 strategy {"max_seconds":1,"strategy":["unit"],"query_preference":0}

proof:
 1: [in, axiom] p(*(2,X)) | -p(X).
 2: [in, axiom] p(2.100000).
 3: [mp, 1.1, 2, fromaxiom] p(4.200000).
 4: [mp, 3, 1.1, fromaxiom] p(8.400000).
 5: [mp, 4, 1.1, fromaxiom] p(16.800000).
 6: [mp, 5, 1.1, fromaxiom] p(33.600000).
 7: [mp, 6, 1.1, fromaxiom] p(67.200000).
 8: [mp, 7, 1.1, fromaxiom] p(134.400000).
 9: [in, axiom] &lt;(X,128) | -p(X).
 10: [mp, 8, 9.1, fromaxiom] false
</code></pre>

<p>Due to the experimental nature, arithmetic is automatically
switched off if the tptp proof format is selected, either by
the <code>-tptp 1</code> parameter or the <code>"print_tptp": 1</code> given in the
strategy file. </p>

<p>The arithmetic syntax used by gkc does not currently conform
to the TPTP format. </p>

<p>While gkc and other provers can - in an ideal world without time and memory restrictions - 
find a solution to any pure first order logic problem which has a solution, they
cannot, in principle (for a number of reasons!) find solutions to all arithmetic 
problems which have a solution.</p>

<p>As a trivial practical example gkc is unable to find that</p>

<pre><code>-p(5).
p(2+X).
</code></pre>

<p>is contradictory. This would require either solving the equation 5=2+X or
generating an ever-growing set of numberic instances of clauses, none
of which gkc currently attempts.</p>

<p>However, for the last example one can construct a number-generating
clause set - which essentially forces the creation of numeric 
instances - like this:</p>

<pre><code>-p(5).
n(0).
-n(X) | n(1+X).
-n(X) | p(2+X).
</code></pre>

<p>leading to a proof</p>

<pre><code>1: [in, axiom] n(+(1,X)) | -n(X).
2: [in, axiom] n(0).
3: [mp, 1.1, 2, fromaxiom] n(1).
4: [mp, 3, 1.1, fromaxiom] n(2).
5: [mp, 4, 1.1, fromaxiom] n(3).
6: [in, axiom] p(+(2,X)) | -n(X).
7: [in, axiom] -p(5).
8: [mp, 5, 6.1, 7, fromaxiom] false
</code></pre>

<h3>Large theory batch files</h3>

<p>Gkc is capable of time-efficiently handling a special format of 
packaging a large number of proof tasks into a single batch run file.
These pages contain a description of the format and specific requirements: </p>

<ul>
<li><a href="http://www.tptp.org/CASC/J10/Design.html#Problems">CASC J10 design: Problems</a></li>
<li><a href="http://www.tptp.org/CASC/J10/Design.html#SystemProperties">CASC J10 design: System properties</a></li>
</ul>

<p>In order to try out a simple example, there is <a href="largebatch.txt">largebatch.txt</a> file:</p>

<pre><code>mkdir out
./gkc largebatch.txt out
</code></pre>

<p>Here gkc determines automatically that the largebatch.txt
has a specific format and should be handled as a batch of
problems, with output files put into the out folder.</p>

<p>This capability is only available under UNIX.</p>

</div>

<!-- at-end-scripts -->

<script>
// instead of jquery
function gid(x) { return document.getElementById(x); }
// reading a file
function handleFileSelect(evt) {
  var files = evt.target.files; 
  for (var i = 0, f; f = files[i]; i++) {
    var reader = new FileReader();
    reader.onload = (function(theFile) {
      return function(e) { gid('gkc_1_input').value=e.target.result; };
    })(f);
    reader.readAsText(f);
  }
}
// do this to initialize file reading:
gid('files').addEventListener('change', handleFileSelect, false);

// example data

var examples=
{"1":
  {"data":"p(a). \n -p(a).",
  "notes":""}
};

</script>
<!-- ui with bootstrap -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<!-- Solver code -->
<script async src="gkcjs.js"></script>
<!--
<script>
// google analytics
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61132529-1', 'auto');
  ga('send', 'pageview');
</script> 
-->
</body>
</html>
